<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Perspective Trainer</title>
    <link rel="stylesheet" href="css/style.css">
    <script type="text/javascript" src="js/paper-full.min.js"></script>
    <script type="text/paperscript" canvas="canvas">

        /*
        TODO
        touch support
        back rectangle scoring
        variable difficulty via longer guide lines
        */
        var path;

        var rect = new Rectangle();
        rect.left = randInt(50, 400);
        rect.right = rect.left + randInt(50, 100);
        rect.top = randInt(50, 400);
        rect.bottom = rect.top + randInt(50, 100);

        var rectPath = new Path.Rectangle(rect);
        rectPath.strokeColor='black';

        var vp = new Point(randInt(50,400),randInt(50,400));
        var horizonPath = new Path();
        horizonPath.strokeColor='black';
        horizonPath.add(new Point(30, vp.y), new Point(600, vp.y));

        var vpCircle = new Path.Circle(vp, 3);
        vpCircle.fillColor='black';

        var topLeftCircle = new Path.Circle(new Point(0, 0), 3);
        topLeftCircle.position = new Point(rect.left, rect.top);
        topLeftCircle.fillColor='black';
        topLeftCircle.strokeColor='black';
        topLeftCircle.strokeWidth=0;

        var topRightCircle = new Path.Circle(new Point(0, 0), 3);
        topRightCircle.position = new Point(rect.right, rect.top);
        topRightCircle.fillColor='black';
        topRightCircle.strokeColor='black';
        topRightCircle.strokeWidth=0;

        var botLeftCircle = new Path.Circle(new Point(0, 0), 3);
        botLeftCircle.position = new Point(rect.left, rect.bottom);
        botLeftCircle.fillColor='black';
        botLeftCircle.strokeColor='black';
        botLeftCircle.strokeWidth=0;

        var botRightCircle = new Path.Circle(new Point(0, 0), 3);
        botRightCircle.position = new Point(rect.right, rect.bottom);
        botRightCircle.fillColor='black';
        botRightCircle.strokeColor='black';
        botRightCircle.strokeWidth=0;

        var selectedVertex = "none";
        var activePath = "none";

        var topLeftPath = new Path();
        topLeftPath.strokeColor = 'transparent';
        var topRightPath = new Path();
        topRightPath.strokeColor = 'transparent';
        var botLeftPath = new Path();
        botLeftPath.strokeColor = 'transparent';
        var botRightPath = new Path();
        botRightPath.strokeColor = 'transparent';

        var topLeftPathTest = new Path();
        topLeftPathTest.strokeColor = 'transparent';
        topLeftPathTest.add(new Point(rect.left, rect.top));
        topLeftPathTest.add(vp);
        
        var topRightPathTest = new Path();
        topRightPathTest.strokeColor = 'transparent';
        topRightPathTest.add(new Point(rect.right, rect.top));
        topRightPathTest.add(vp);

        var botLeftPathTest = new Path();
        botLeftPathTest.strokeColor = 'transparent';
        botLeftPathTest.add(new Point(rect.left, rect.bottom));
        botLeftPathTest.add(vp);

        var botRightPathTest = new Path();
        botRightPathTest.strokeColor = 'transparent';
        botRightPathTest.add(new Point(rect.right, rect.bottom));
        botRightPathTest.add(vp);

        var backPathColor = 'grey';
        var backTopPath = new Path();
        backTopPath.strokeColor = 'trasparent';
        backTopPath.add(new Point(0,0), new Point(0,0));
        var backLeftPath = new Path();
        backLeftPath.strokeColor = 'trasparent';
        backLeftPath.add(new Point(0,0), new Point(0,0));
        var backRightPath = new Path();
        backRightPath.strokeColor = 'trasparent';
        backRightPath.add(new Point(0,0), new Point(0,0));
        var backBotPath = new Path();
        backBotPath.strokeColor = 'trasparent';
        backBotPath.add(new Point(0,0), new Point(0,0));

        var buttonTest = new Path.Rectangle(new Rectangle(10,10,100,35),6);
        buttonTest.fillColor='#00000011';
        var buttonTestText = new PointText(buttonTest.position);
        buttonTestText.content = 'Test';
        buttonTestText.justification = 'center';
        buttonTestText.fillColor = 'black';
        buttonTestText.onMouseDown = buttonTest.onMouseDown = function(event) { testAll(); buttonTest.fillColor = '#00000033';}
        buttonTestText.onMouseUp = buttonTest.onMouseUp = function(event) { hideAllTestPaths(); buttonTest.fillColor = '#00000011';}
        
        var scorePanel = new Path.Rectangle(new Rectangle(120,10,200,35),6);
        scorePanel.fillColor='#00000011';
        var scoreLabelText = new PointText(scorePanel.position + new Point(-80, 0));
        scoreLabelText.content = 'Score:';
        scoreLabelText.justification = 'left';
        scoreLabelText.fillColor = 'black';
        var scoreValueText = new PointText(scorePanel.position + new Point(-40, 0));
        scoreValueText.content = '0';
        scoreValueText.justification = 'left';
        scoreValueText.fillColor = 'black';

        function onMouseDrag(event) {
            if (activePath == "none") return;
            
            var xoffset = 25;

            if (activePath == "topLeft") {
                if (topLeftPath.segments.length < 2) topLeftPath.add(event.point);
                if (vp.x < rect.left) xoffset = -xoffset;
                topLeftPath.segments[1].point.x = event.point.x + xoffset;
                topLeftPath.segments[1].point.y = event.point.y;
                topLeftCircle.position = new Point(event.point.x + xoffset, event.point.y);
            } else if (activePath == "topRight") {
                if (topRightPath.segments.length < 2) topRightPath.add(event.point);
                if (vp.x < rect.right) xoffset = -xoffset;
                topRightPath.segments[1].point.x = event.point.x + xoffset;
                topRightPath.segments[1].point.y = event.point.y;
                topRightCircle.position = new Point(event.point.x + xoffset, event.point.y);
            } else if (activePath == "botLeft") {
                if (botLeftPath.segments.length < 2) botLeftPath.add(event.point);
                if (vp.x < rect.left) xoffset = -xoffset;
                botLeftPath.segments[1].point.x = event.point.x + xoffset;
                botLeftPath.segments[1].point.y = event.point.y;
                botLeftCircle.position = new Point(event.point.x + xoffset, event.point.y);
            } else if (activePath == "botRight") {
                if (botRightPath.segments.length < 2) botRightPath.add(event.point);
                if (vp.x < rect.right) xoffset = -xoffset;
                botRightPath.segments[1].point.x = event.point.x + xoffset;
                botRightPath.segments[1].point.y = event.point.y;
                botRightCircle.position = new Point(event.point.x + xoffset, event.point.y);
            }
            
        }
        
        function onMouseDown(event) {
            if (selectedVertex == "none") return;
            hideAllTestPaths();
            resetVertexStrokeWidth();
            if (selectedVertex == "topLeft") {  
                topLeftPath.add(new Point(rect.left, rect.top));
                activePath = "topLeft";
                topLeftPath.strokeColor='transparent';
                
                backLeftPath.strokeColor = 'transparent';
                backTopPath.strokeColor = 'transparent';

            } else if (selectedVertex == "topRight") {  
                topRightPath.add(new Point(rect.right, rect.top));
                activePath = "topRight";
                topRightPath.strokeColor='transparent';
                
                backRightPath.strokeColor = 'transparent';
                backTopPath.strokeColor = 'transparent';
            } else if (selectedVertex == "botLeft") {  
                botLeftPath.add(new Point(rect.left, rect.bottom));
                activePath = "botLeft";
                botLeftPath.strokeColor='transparent';

                backLeftPath.strokeColor = 'transparent';
                backBotPath.strokeColor = 'transparent';
            } else if (selectedVertex == "botRight") {  
                botRightPath.add(new Point(rect.right, rect.bottom));
                activePath = "botRight";
                botRightPath.strokeColor='transparent';

                backRightPath.strokeColor = 'transparent';
                backBotPath.strokeColor = 'transparent';
            }
        }

        function onMouseMove(event) {
            var grabDist = 50;
            var circleGrowWidth = 10;
            resetVertexStrokeWidth()
            if (dist(event.point, topLeftCircle.position) < grabDist) {
                topLeftCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "topLeft";
            } else if (dist(event.point, topRightCircle.position) < grabDist) {
                topRightCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "topRight";
            } else if (dist(event.point, botLeftCircle.position) < grabDist) {
                botLeftCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "botLeft";
            } else if (dist(event.point, botRightCircle.position) < grabDist) {
                botRightCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "botRight";
            } else {
                selectedVertex = "none";
            }
        }

        function onMouseUp(event) {
            if (activePath == "topLeft") {
                topLeftPath.strokeColor = 'black';
            } else if (activePath == "topRight") {
                topRightPath.strokeColor = 'black';
            } else if (activePath == "botLeft"){
                botLeftPath.strokeColor = 'black';
            } else if (activePath == "botRight") {
                botRightPath.strokeColor = 'black';
            }
            activePath = "none";
            selectedVertex = "none";
            topLeftCircle.position = new Point(rect.left, rect.top);
            topRightCircle.position = new Point(rect.right, rect.top);
            botLeftCircle.position = new Point(rect.left, rect.bottom);
            botRightCircle.position = new Point(rect.right, rect.bottom);
            drawBackLines();
        }

        function drawBackLines() {
            if (topLeftPath.segments.length > 1 & topRightPath.segments.length > 1) {
                backTopPath.strokeColor = backPathColor;
                backTopPath.segments[0].point = topLeftPath.segments[1].point;
                backTopPath.segments[1].point = topRightPath.segments[1].point;
            }
            if (topRightPath.segments.length > 1 & botRightPath.segments.length > 1) {
                backRightPath.strokeColor = backPathColor;
                backRightPath.segments[0].point = topRightPath.segments[1].point;
                backRightPath.segments[1].point = botRightPath.segments[1].point;
            }
            if (botRightPath.segments.length > 1 & botLeftPath.segments.length > 1) {
                backBotPath.strokeColor = backPathColor;
                backBotPath.segments[0].point = botRightPath.segments[1].point;
                backBotPath.segments[1].point = botLeftPath.segments[1].point;
            }
            if (topLeftPath.segments.length > 1 & botLeftPath.segments.length > 1) {
                backLeftPath.strokeColor = backPathColor;
                backLeftPath.segments[0].point = botLeftPath.segments[1].point;
                backLeftPath.segments[1].point = topLeftPath.segments[1].point;
            }
        }

        function resetVertexStrokeWidth() {
            topLeftCircle.strokeWidth=0;
            topRightCircle.strokeWidth=0;
            botLeftCircle.strokeWidth=0;
            botRightCircle.strokeWidth=0;
        }

        function dist(p1, p2) {
            var delta = p1 - p2;
            return (Math.sqrt(Math.pow(delta.x,2) + Math.pow(delta.y,2)));
        }

        function hideAllTestPaths() {
            topLeftPathTest.strokeColor='transparent';
            topRightPathTest.strokeColor='transparent';
            botLeftPathTest.strokeColor='transparent';
            botRightPathTest.strokeColor='transparent';
        }

        function testAll() {
            var score = testTopLeftPath() +  testTopRightPath() + testBotLeftPath() + testBotRightPath();
            scoreValueText.content = score;
        }

        function testTopLeftPath() {
            var p1 = topLeftPath.segments[0].point;
            var p2 = topLeftPath.segments[1].point;
            topLeftPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            topLeftPathTest.segments[1].point.y = vp.y;
            topLeftPathTest.strokeColor='red';
            return Math.pow(vp.x - topLeftPathTest.segments[1].point.x,2);
        }
        function testTopRightPath() {
            var p1 = topRightPath.segments[0].point;
            var p2 = topRightPath.segments[1].point;
            topRightPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            topRightPathTest.segments[1].point.y = vp.y;
            topRightPathTest.strokeColor='red';
            return Math.pow(vp.x - topRightPathTest.segments[1].point.x,2);
        }
        function testBotLeftPath() {
            var p1 = botLeftPath.segments[0].point;
            var p2 = botLeftPath.segments[1].point;
            botLeftPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            botLeftPathTest.segments[1].point.y = vp.y;
            botLeftPathTest.strokeColor='red';
            return Math.pow(vp.x - botLeftPathTest.segments[1].point.x,2);
        }
        function testBotRightPath() {
            var p1 = botRightPath.segments[0].point;
            var p2 = botRightPath.segments[1].point;
            botRightPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            botRightPathTest.segments[1].point.y = vp.y;
            botRightPathTest.strokeColor='red';
            return Math.pow(vp.x - botRightPathTest.segments[1].point.x,2);
        }
        function randInt(min, max) {
            return Math.floor(Math.random() * (max - min) ) + min;
        }
    </script>
</head>
<body>
    <canvas id="canvas" resize></canvas>
</body>
</html>
