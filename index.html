<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Perspective Trainer</title>
    <link rel="stylesheet" href="css/style.css">

    <script type="text/javascript" src="js/paper-full.min.js"></script>
    <script type="text/paperscript" canvas="canvas">

        /*
        TODO
        touch support
        back rectangle scoring
        variable difficulty via longer guide lines
        */
        var palette = ["#fff4e0",
                       "#8fcccb",
                       "#449489",
                       "#285763",
                       "#2f2b5c",
                       "#4b3b9c",
                       "#457cd6",
                       "#f2b63d",
                       "#d46e33",
                       "#e34262",
                       "#94353d",
                       "#57253b",
                       "#9c656c",
                       "#d1b48c",
                       "#b4ba47",
                       "#6d8c32",
                       "#2c1b2e"];
        document.body.style.backgroundColor = "#ffffffff";
        var frameStroke = palette[16];
        var frameFill = palette[0];
        var frameStrokeWidth = 3;
        var frameDashArray = [0];

        var rectStroke = palette[13];
        var rectFill = palette[13];
        var rectStrokeWidth = 2;
        var rectDashArray = [0];
        var rectStrokeAlpha = .75;
        var rectFillAlpha = .2;

        var vpStroke = palette[3];
        var vpFill = palette[3];
        var vpStrokeWidth = 10;
        var vpDashArray = [0];
        var vpStrokeAlpha = .75;
        var vpFillAlpha = .75;

        var horizonStroke = palette[3];
        var horizonStrokeWidth = 2;
        var horizonStrokeAlpha = .75;

        var anchorStroke = palette[12];
        var anchorFill = palette[12];
        var anchorStrokeWidth = 0;
        var anchorDashArray = [0];
        var anchorStrokeAlpha = .75;
        var anchorFillAlpha = 1;

        var anchorRingRadius = 10;
        var anchorRingStroke = palette[12];
        var anchorRingFill = palette[12] + '00';
        var anchorRingStrokeWidth = 1;
        var anchorRingDashArray = [1,3];

        var anchorRingClickRadius = 13;
        var anchorRingClickStroke = palette[12];
        var anchorRingClickFill = palette[12] + '55';
        var anchorRingClickStrokeWidth = 1;
        var anchorRingClickDashArray = [1,3];
        var anchorRingClickTweenDuration = 200;

        var boxPathStroke = palette[13];
        var boxPathStrokeUnacceptable = palette[8];
        var boxPathStrokeWidth = 3;
        var boxPathDashArray = [5,5];
        var boxPathStrokeAlpha = .75;

        var guidePercent = .5;
        var pointDistPercent = .5;
        var rectSizeProp = .4;
        var rectSizePropVar = .35;

        var path;
        var clickStartPoint = new Point(0,0);

        var frame = new Rectangle();
        var framePath = new Path.Rectangle(frame);
        var rect = new Rectangle();
        var rectPath = new Path.Rectangle(rect);

        var vp = new Point(randInt(frame.left + 20,frame.right-20),randInt(frame.top+20, frame.bottom-20));
        var horizonPath = new Path();
        var vpCircle = new Path.Circle(vp, 3);
        var topLeftCircle = new Path.Circle(new Point(0, 0), 3);
        var topRightCircle = new Path.Circle(new Point(0, 0), 3);
        var botLeftCircle = new Path.Circle(new Point(0, 0), 3);
        var botRightCircle = new Path.Circle(new Point(0, 0), 3);

        var topLeftCircleRing = new Path.Circle({insert: false});
        var topLeftCircleRingClick = new Path.Circle({insert: false});
        var topLeftCircleRingUnclicked = new Path.Circle({insert: false});

        var selectedVertex = "none";
        var activePath = "none";
        var topLeftPath = new Path();
        var topRightPath = new Path();
        var botLeftPath = new Path();
        var botRightPath = new Path();

        var topLeftPathTest = new Path();
        var topRightPathTest = new Path();
        var botLeftPathTest = new Path();
        var botRightPathTest = new Path();
        var topLeftPathGuide = new Path();
        var topRightPathGuide = new Path();
        var botLeftPathGuide = new Path();
        var botRightPathGuide = new Path();

        var backPathColor = 'grey';
        var backTopPath = new Path();
        var backLeftPath = new Path();
        var backRightPath = new Path();
        var backBotPath = new Path();

        var backGuideColor = '#CCEE55CC';
        var backGuideArray = [3, 5];

        var topLeftBackHorizontalGuide = new Path();
        var topLeftBackVerticalGuide = new Path();
        var topRightBackHorizontalGuide = new Path();
        var topRightBackVerticalGuide = new Path();
        var botLeftBackHorizontalGuide = new Path();
        var botLeftBackVerticalGuide = new Path();
        var botRightBackHorizontalGuide = new Path();
        var botRightBackVerticalGuide = new Path();

        var buttonTest = new Path.Rectangle(new Rectangle(10,10,100,35),6);
        buttonTest.fillColor='#00000011';
        var buttonTestText = new PointText(buttonTest.position);
        buttonTestText.content = 'Test';
        buttonTestText.justification = 'center';
        buttonTestText.fillColor = 'black';
        buttonTestText.onMouseDown = buttonTest.onMouseDown = function(event) { testAll(); buttonTest.fillColor = '#00000033';}
        buttonTestText.onMouseUp = buttonTest.onMouseUp = function(event) { hideAllTestPaths(); buttonTest.fillColor = '#00000011';}
        
        var scorePanel = new Path.Rectangle(new Rectangle(120,10,200,35),6);
        scorePanel.fillColor='#00000011';
        var scoreLabelText = new PointText(scorePanel.position + new Point(-80, 0));
        scoreLabelText.content = 'Score:';
        scoreLabelText.justification = 'left';
        scoreLabelText.fillColor = 'black';
        var scoreValueText = new PointText(scorePanel.position + new Point(-40, 0));
        scoreValueText.content = '0';
        scoreValueText.justification = 'left';
        scoreValueText.fillColor = 'black';

        var buttonDifficulty = new Path.Rectangle(new Rectangle(330,10,100,35),6);
        buttonDifficulty.fillColor='#00000011';
        var buttonDifficultyText = new PointText(buttonDifficulty.position);
        buttonDifficultyText.content = 'Easy';
        buttonDifficultyText.justification = 'center';
        buttonDifficultyText.fillColor = 'black';
        buttonDifficultyText.onMouseDown = buttonDifficulty.onMouseDown = function(event) { buttonDifficulty.fillColor = '#00000033';}
        buttonDifficultyText.onMouseUp = buttonDifficulty.onMouseUp = function(event) { 
            if (buttonDifficultyText.content == 'Easy') {
                buttonDifficultyText.content = 'Moderate';
                guidePercent = .3;
                backGuideColor = '#CCEE5599';
            } else if (buttonDifficultyText.content == 'Moderate') {
                buttonDifficultyText.content = 'Hard';
                guidePercent = .1;
                backGuideColor = '#CCEE5555';
            } else if (buttonDifficultyText.content == 'Hard') {
                buttonDifficultyText.content = 'No Help!';
                guidePercent = 0;
                backGuideColor = '#CCEE5500';
            } else if (buttonDifficultyText.content == 'No Help!') {
                buttonDifficultyText.content = 'Easy';
                guidePercent = .5;
                backGuideColor = '#CCEE55CC';
            } 
            buttonDifficulty.fillColor = '#00000011';
        }

        var buttonNew = new Path.Rectangle(new Rectangle(440,10,100,35),6);
        buttonNew.fillColor='#00000011';
        var buttonNewText = new PointText(buttonNew.position);
        buttonNewText.content = 'Next';
        buttonNewText.justification = 'center';
        buttonNewText.fillColor = 'black';
        buttonNewText.onMouseDown = buttonNew.onMouseDown = function(event) { buttonNew.fillColor = '#00000033';}
        buttonNewText.onMouseUp = buttonNew.onMouseUp = function(event) { 
            buttonNew.fillColor='#00000011';
            initialize();
        }

        var randDistScale = 1;

        initialize();

        function initialize() {
            frame = new Rectangle();
            frame.left = 30;
            frame.right = window.innerWidth-30;
            frame.top = 60;
            frame.bottom = window.innerHeight-30;

            framePath.remove();

            framePath = new Path.Rectangle(frame);
            framePath.strokeColor = frameStroke;
            framePath.fillColor = frameFill;
            framePath.strokeWidth = frameStrokeWidth;
            framePath.dashArray = frameDashArray;

            rect.left = randInt(frame.left+20, frame.right-(frame.right-frame.left)*(rectSizeProp+rectSizePropVar)-30);
            rect.right = rect.left + randInt((frame.right-frame.left)*(rectSizeProp-rectSizePropVar), (frame.right-frame.left)*(rectSizeProp+rectSizePropVar));
            rect.top = randInt(frame.top+20, frame.bottom-(frame.bottom-frame.top)*(rectSizeProp+rectSizePropVar)-30);
            rect.bottom = rect.top + randInt((frame.bottom-frame.top)*(rectSizeProp-rectSizePropVar), (frame.bottom-frame.top)*(rectSizeProp+rectSizePropVar));
            rectPath.remove();
            rectPath = new Path.Rectangle(rect);
            
            rectPath.strokeColor=rectStroke;
            rectPath.fillColor=rectFill;
            rectPath.strokeWidth=rectStrokeWidth;
            rectPath.dashArray=rectDashArray;
            rectPath.fillColor.alpha = rectFillAlpha;
            rectPath.strokeColor.alpha = rectStrokeAlpha;

            vp = new Point(randInt(frame.left + 20,frame.right-20),randInt(frame.top+20, frame.bottom-20));

            horizonPath.remove();
            horizonPath = new Path();
            horizonPath.strokeColor=horizonStroke;
            horizonPath.strokeWidth=horizonStrokeWidth;
            horizonPath.strokeColor.alpha=horizonStrokeAlpha;
            horizonPath.add(new Point(frame.left, vp.y), new Point(frame.right, vp.y));

            vpCircle.remove();
            vpCircle = new Path.Circle(vp, 3);
            
            vpCircle.strokeColor=vpStroke;
            vpCircle.fillColor=vpFill;
            vpCircle.strokeWidth=vpStrokeWidth;
            vpCircle.dashArray=vpDashArray;
            vpCircle.strokeColor.alpha = vpStrokeAlpha;
            vpCircle.fillColor.alpha = vpFillAlpha;

            topLeftCircle.remove();
            topLeftCircle = new Path.Circle(new Point(0, 0), 5);
            topLeftCircle.position = new Point(rect.left, rect.top);
            topLeftCircle.fillColor=anchorFill;
            topLeftCircle.fillColor.alpha=anchorFillAlpha;
            topLeftCircle.strokeColor=anchorStroke;
            topLeftCircle.strokeColor.alpha=anchorStrokeAlpha;
            topLeftCircle.strokeWidth=anchorStrokeWidth;
            topLeftCircle.dashArray = anchorDashArray;

            topLeftCircleRing.remove();
            topLeftCircleRing = new Path.Circle({position: new Point(rect.left, rect.top), 
                                                 radius: anchorRingRadius,
                                                 fillColor: anchorRingFill,
                                                 strokeColor:anchorRingStroke,
                                                 strokeWidth:anchorRingStrokeWidth,
                                                 dashArray : anchorRingDashArray
                                                });
            topLeftCircleRingUnclicked = topLeftCircleRing.clone({insert: false});

            topLeftCircleRingClick = new Path.Circle({position: new Point(rect.left, rect.top), 
                                                 radius: anchorRingClickRadius,
                                                 fillColor: anchorRingClickFill,
                                                 strokeColor:anchorRingClickStroke,
                                                 strokeWidth:anchorRingClickStrokeWidth,
                                                 dashArray : anchorRingClickDashArray,
                                                 insert: false
                                                });

            topRightCircle.remove();
            topRightCircle = new Path.Circle(new Point(0, 0), 3);
            topRightCircle.position = new Point(rect.right, rect.top);
            topRightCircle.fillColor='black';
            topRightCircle.strokeColor='black';
            topRightCircle.strokeWidth=0;

            botLeftCircle.remove();
            botLeftCircle = new Path.Circle(new Point(0, 0), 3);
            botLeftCircle.position = new Point(rect.left, rect.bottom);
            botLeftCircle.fillColor='black';
            botLeftCircle.strokeColor='black';
            botLeftCircle.strokeWidth=0;

            botRightCircle.remove();
            botRightCircle = new Path.Circle(new Point(0, 0), 3);
            botRightCircle.position = new Point(rect.right, rect.bottom);
            botRightCircle.fillColor='black';
            botRightCircle.strokeColor='black';
            botRightCircle.strokeWidth=0;

            selectedVertex = "none";
            activePath = "none";

            topLeftPath.remove();
            topLeftPath = new Path();
            topLeftPath.insertBelow(topLeftCircle);
            topLeftPath.add(new Point(rect.left, rect.top), new Point(rect.left, rect.top));
            topLeftPath.strokeColor = boxPathStroke;
            topLeftPath.strokeWidth = boxPathStrokeWidth;
            topLeftPath.dashArray = boxPathDashArray;
            topLeftPath.strokeColor.alpha = boxPathStrokeAlpha;

            topRightPath.remove();
            topRightPath = new Path();
            topRightPath.add(new Point(rect.right, rect.top), new Point(rect.right, rect.top));
            topRightPath.strokeColor = 'transparent';
            botLeftPath.remove();
            botLeftPath = new Path();
            botLeftPath.add(new Point(rect.left, rect.bottom), new Point(rect.left, rect.bottom));
            botLeftPath.strokeColor = 'transparent';
            botRightPath.remove();
            botRightPath = new Path();
            botRightPath.add(new Point(rect.right, rect.bottom), new Point(rect.right, rect.bottom));
            botRightPath.strokeColor = 'transparent';

            topLeftPathTest.remove();
            topLeftPathTest = new Path();
            topLeftPathTest.strokeColor = 'transparent';
            topLeftPathTest.add(new Point(rect.left, rect.top));
            topLeftPathTest.add(vp);
            
            topRightPathTest.remove();
            topRightPathTest = new Path();
            topRightPathTest.strokeColor = 'transparent';
            topRightPathTest.add(new Point(rect.right, rect.top));
            topRightPathTest.add(vp);

            botLeftPathTest.remove();
            botLeftPathTest = new Path();
            botLeftPathTest.strokeColor = 'transparent';
            botLeftPathTest.add(new Point(rect.left, rect.bottom));
            botLeftPathTest.add(vp);

            botRightPathTest.remove();
            botRightPathTest = new Path();
            botRightPathTest.strokeColor = 'transparent';
            botRightPathTest.add(new Point(rect.right, rect.bottom));
            botRightPathTest.add(vp);

            topLeftPathGuide.remove();
            topLeftPathGuide = new Path();
            topLeftPathGuide.strokeColor = 'transparent';
            topLeftPathGuide.add(new Point(rect.left, rect.top));
            topLeftPathGuide.add(vp);
            
            topRightPathGuide.remove();
            topRightPathGuide = new Path();
            topRightPathGuide.strokeColor = 'transparent';
            topRightPathGuide.add(new Point(rect.right, rect.top));
            topRightPathGuide.add(vp);

            botLeftPathGuide.remove();
            botLeftPathGuide = new Path();
            botLeftPathGuide.strokeColor = 'transparent';
            botLeftPathGuide.add(new Point(rect.left, rect.bottom));
            botLeftPathGuide.add(vp);

            botRightPathGuide.remove();
            botRightPathGuide = new Path();
            botRightPathGuide.strokeColor = 'transparent';
            botRightPathGuide.add(new Point(rect.right, rect.bottom));
            botRightPathGuide.add(vp);


            backTopPath.remove();
            backTopPath = new Path();
            backTopPath.strokeColor = 'trasparent';
            backTopPath.add(new Point(0,0), new Point(0,0));
            backLeftPath.remove();
            backLeftPath = new Path();
            backLeftPath.strokeColor = 'trasparent';
            backLeftPath.add(new Point(0,0), new Point(0,0));
            backRightPath.remove();
            backRightPath = new Path();
            backRightPath.strokeColor = 'trasparent';
            backRightPath.add(new Point(0,0), new Point(0,0));
            backBotPath.remove();
            backBotPath = new Path();
            backBotPath.strokeColor = 'trasparent';
            backBotPath.add(new Point(0,0), new Point(0,0));


            topLeftBackHorizontalGuide = new Path();
            topLeftBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
            topLeftBackHorizontalGuide.strokeColor = backGuideColor;
            topLeftBackHorizontalGuide.dashArray = backGuideArray;
            topLeftBackVerticalGuide = new Path();
            topLeftBackVerticalGuide.add(new Point(0,0), new Point(0,0));
            topLeftBackVerticalGuide.strokeColor = backGuideColor;
            topLeftBackVerticalGuide.dashArray = backGuideArray;
            topRightBackHorizontalGuide = new Path();
            topRightBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
            topRightBackHorizontalGuide.strokeColor = backGuideColor;
            topRightBackHorizontalGuide.dashArray = backGuideArray;
            topRightBackVerticalGuide = new Path();
            topRightBackVerticalGuide.add(new Point(0,0), new Point(0,0));
            topRightBackVerticalGuide.strokeColor = backGuideColor;
            topRightBackVerticalGuide.dashArray = backGuideArray;
            botLeftBackHorizontalGuide = new Path();
            botLeftBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
            botLeftBackHorizontalGuide.strokeColor = backGuideColor;
            botLeftBackHorizontalGuide.dashArray = backGuideArray;
            botLeftBackVerticalGuide = new Path();
            botLeftBackVerticalGuide.add(new Point(0,0), new Point(0,0));
            botLeftBackVerticalGuide.strokeColor = backGuideColor;
            botLeftBackVerticalGuide.dashArray = backGuideArray;
            botRightBackHorizontalGuide = new Path();
            botRightBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
            botRightBackHorizontalGuide.strokeColor = backGuideColor;
            botRightBackHorizontalGuide.dashArray = backGuideArray;
            botRightBackVerticalGuide = new Path();
            botRightBackVerticalGuide.add(new Point(0,0), new Point(0,0));
            botRightBackVerticalGuide.strokeColor = backGuideColor;
            botRightBackVerticalGuide.dashArray = backGuideArray;
            
        }


        function onMouseDrag(event) {
            var cursorpoint = event.point;
            if (event.point.x < frame.left) return;
            if (event.point.x > frame.right) return;
            if (event.point.y < frame.top) return;
            if (event.point.y > frame.bottom) return;

            if (activePath == "none") return;

            if (activePath == "topLeft") {
                cursorpoint = topLeftPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, topLeftPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(topLeftPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = topLeftPath.segments[0].point.x + (cursorpoint.x - topLeftPath.segments[0].point.x)/scalingFactor;
                var y = topLeftPath.segments[0].point.y + (cursorpoint.y - topLeftPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    topLeftPath.strokeColor = boxPathStrokeUnacceptable;
                } else {
                    topLeftPath.strokeColor = boxPathStroke;

                    topLeftPath.segments[1].point.x = x;
                    topLeftPath.segments[1].point.y = y;
    
                    topLeftCircle.position = new Point(x, y);
                }
            } else if (activePath == "topRight") {
                cursorpoint = topRightPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, topRightPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(topRightPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = topRightPath.segments[0].point.x + (cursorpoint.x - topRightPath.segments[0].point.x)/scalingFactor;
                var y = topRightPath.segments[0].point.y + (cursorpoint.y - topRightPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    topRightCircle.strokeColor = 'red';
                    topRightPath.strokeColor = 'red';
                } else {
                    topRightCircle.strokeColor = 'black';
                    topRightPath.strokeColor = 'black';

                    topRightPath.segments[1].point.x = x;
                    topRightPath.segments[1].point.y = y;
    
                    topRightCircle.position = new Point(x, y);
                }
            } else if (activePath == "botLeft") {
                cursorpoint = botLeftPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, botLeftPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(botLeftPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = botLeftPath.segments[0].point.x + (cursorpoint.x - botLeftPath.segments[0].point.x)/scalingFactor;
                var y = botLeftPath.segments[0].point.y + (cursorpoint.y - botLeftPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    botLeftCircle.strokeColor = 'red';
                    botLeftPath.strokeColor = 'red';
                } else {
                    botLeftCircle.strokeColor = 'black';
                    botLeftPath.strokeColor = 'black';

                    botLeftPath.segments[1].point.x = x;
                    botLeftPath.segments[1].point.y = y;
    
                    botLeftCircle.position = new Point(x, y);
                }
            } else if (activePath == "botRight") {
                cursorpoint = botRightPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, botRightPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(botRightPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = botRightPath.segments[0].point.x + (cursorpoint.x - botRightPath.segments[0].point.x)/scalingFactor;
                var y = botRightPath.segments[0].point.y + (cursorpoint.y - botRightPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    botRightCircle.strokeColor = 'red';
                    botRightPath.strokeColor = 'red';
                } else {
                    botRightCircle.strokeColor = 'black';
                    botRightPath.strokeColor = 'black';

                    botRightPath.segments[1].point.x = x;
                    botRightPath.segments[1].point.y = y;
    
                    botRightCircle.position = new Point(x, y);
                }
            }
            showGuides();
        }
        
        function onMouseDown(event) {

            if (event.point.x < frame.left) return;
            if (event.point.x > frame.right) return;
            if (event.point.y < frame.top) return;
            if (event.point.y > frame.bottom) return;

            selectVertex(event);
            randDistScale = randInt(100,140)/100;
            if (selectedVertex == "none") {
                return;
            }
            hideAllTestPaths();
            clickStartPoint = event.point;
            
            
            if (selectedVertex == "topLeft") {  
                topLeftPath.segments[0].point = new Point(rect.left, rect.top);
                activePath = "topLeft";
                
                backLeftPath.strokeColor = 'transparent';
                backTopPath.strokeColor = 'transparent';

            } else if (selectedVertex == "topRight") {  
                topRightPath.add(new Point(rect.right, rect.top));
                activePath = "topRight";
                topRightPath.strokeColor='transparent';
                
                backRightPath.strokeColor = 'transparent';
                backTopPath.strokeColor = 'transparent';
            } else if (selectedVertex == "botLeft") {  
                botLeftPath.add(new Point(rect.left, rect.bottom));
                activePath = "botLeft";
                botLeftPath.strokeColor='transparent';

                backLeftPath.strokeColor = 'transparent';
                backBotPath.strokeColor = 'transparent';
            } else if (selectedVertex == "botRight") {  
                botRightPath.add(new Point(rect.right, rect.bottom));
                activePath = "botRight";
                botRightPath.strokeColor='transparent';

                backRightPath.strokeColor = 'transparent';
                backBotPath.strokeColor = 'transparent';
            }
        }

        function selectVertex(event) {
            var grabDist = 50;
            var circleGrowWidth = 5;

            if (dist(event.point, topLeftCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                //topLeftCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "topLeft";

                changeAnchorRing(topLeftCircleRing, topLeftCircleRingClick);
            } else if (dist(event.point, topRightCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                topRightCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "topRight";

            } else if (dist(event.point, botLeftCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                botLeftCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "botLeft";

            } else if (dist(event.point, botRightCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                botRightCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "botRight";

            } else if (event.point.x < frame.left | event.point.x > frame.right | event.point.y < frame.top | event.point.y > frame.bottom) {
                selectedVertex = "none";
                resetVertexStrokeWidth();
            }
        }

        function changeAnchorRing(path, pathTo) {
            var pathFrom = path.clone({insert: false});
            path.tween(anchorRingClickTweenDuration).onUpdate = function(event) {
                var d = Math.pow(event.factor, .25);
                path.interpolate(pathFrom, pathTo, d);  
                path.fillColor = pathFrom.fillColor*(1-d) + pathTo.fillColor*d;
                path.fillColor.alpha = pathFrom.fillColor.alpha*(1-d) + pathTo.fillColor.alpha*d;

            }
        }

        function onMouseUp(event) {
            if (activePath == "topLeft") {
                topLeftPath.strokeColor = boxPathStroke;
                changeAnchorRing(topLeftCircleRing, topLeftCircleRingUnclicked);
            } else if (activePath == "topRight") {
                topRightPath.strokeColor = 'black';
            } else if (activePath == "botLeft"){
                botLeftPath.strokeColor = 'black';
            } else if (activePath == "botRight") {
                botRightPath.strokeColor = 'black';
            }
            
            //activePath = "none";
            //selectedVertex = "none";
            topLeftCircle.position = new Point(rect.left, rect.top);
            topRightCircle.position = new Point(rect.right, rect.top);
            botLeftCircle.position = new Point(rect.left, rect.bottom);
            botRightCircle.position = new Point(rect.right, rect.bottom);
            drawBackLines();
            hideGuides();
        }
        function clamp(min, max, v) {
            return Math.min(max, Math.max(min, v));
        }

        function showGuides(event) {
            if (activePath == "topLeft") {
                topLeftPathGuide.strokeColor = "blue";
                topLeftPathGuide.dashArray = [2,4];

                topLeftPathGuide.segments[0].point.x = topLeftPath.segments[1].point.x;
                topLeftPathGuide.segments[0].point.y = topLeftPath.segments[1].point.y;

                var p1 = topLeftPath.segments[0].point;
                var p2 = topLeftPath.segments[1].point;

                var targety = topLeftPathGuide.segments[0].point.y + (vp.y - topLeftPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                topLeftPathGuide.segments[1].point.x = xclamped;
                topLeftPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;

            } else if (activePath == "topRight") {
                topRightPathGuide.strokeColor = "blue";
                topRightPathGuide.dashArray = [2,4];

                topRightPathGuide.segments[0].point.x = topRightPath.segments[1].point.x;
                topRightPathGuide.segments[0].point.y = topRightPath.segments[1].point.y;

                var p1 = topRightPath.segments[0].point;
                var p2 = topRightPath.segments[1].point;

                var targety = topRightPathGuide.segments[0].point.y + (vp.y - topRightPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                topRightPathGuide.segments[1].point.x = xclamped;
                topRightPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;

            } else if (activePath == "botLeft") {
                botLeftPathGuide.strokeColor = "blue";
                botLeftPathGuide.dashArray = [2,4];

                botLeftPathGuide.segments[0].point.x = botLeftPath.segments[1].point.x;
                botLeftPathGuide.segments[0].point.y = botLeftPath.segments[1].point.y;

                var p1 = botLeftPath.segments[0].point;
                var p2 = botLeftPath.segments[1].point;

                var targety = botLeftPathGuide.segments[0].point.y + (vp.y - botLeftPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                botLeftPathGuide.segments[1].point.x = xclamped;
                botLeftPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;

            } else if (activePath == "botRight") {
                botRightPathGuide.strokeColor = "blue";
                botRightPathGuide.dashArray = [2,4];

                botRightPathGuide.segments[0].point.x = botRightPath.segments[1].point.x;
                botRightPathGuide.segments[0].point.y = botRightPath.segments[1].point.y;

                var p1 = botRightPath.segments[0].point;
                var p2 = botRightPath.segments[1].point;

                var targety = botRightPathGuide.segments[0].point.y + (vp.y - botRightPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                botRightPathGuide.segments[1].point.x = xclamped;
                botRightPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;
            }

            if (topLeftPath.segments[1].point != topLeftPath.segments[0].point) {
                topLeftBackHorizontalGuide.strokeColor = backGuideColor;
                topLeftBackHorizontalGuide.segments[0].point = new Point(frame.left, topLeftPath.segments[1].point.y);
                topLeftBackHorizontalGuide.segments[1].point = new Point(frame.right, topLeftPath.segments[1].point.y);
                topLeftBackVerticalGuide.strokeColor = backGuideColor;
                topLeftBackVerticalGuide.segments[0].point = new Point(topLeftPath.segments[1].point.x, frame.top);
                topLeftBackVerticalGuide.segments[1].point = new Point(topLeftPath.segments[1].point.x, frame.bottom);
            }
            if (topRightPath.segments[1].point != topRightPath.segments[0].point) {
                topRightBackHorizontalGuide.strokeColor = backGuideColor;
                topRightBackHorizontalGuide.segments[0].point = new Point(frame.left, topRightPath.segments[1].point.y);
                topRightBackHorizontalGuide.segments[1].point = new Point(frame.right, topRightPath.segments[1].point.y);
                topRightBackVerticalGuide.strokeColor = backGuideColor;
                topRightBackVerticalGuide.segments[0].point = new Point(topRightPath.segments[1].point.x, frame.top);
                topRightBackVerticalGuide.segments[1].point = new Point(topRightPath.segments[1].point.x, frame.bottom);
            }
            if (botLeftPath.segments[1].point != botLeftPath.segments[0].point) {
                botLeftBackHorizontalGuide.strokeColor = backGuideColor;
                botLeftBackHorizontalGuide.segments[0].point = new Point(frame.left, botLeftPath.segments[1].point.y);
                botLeftBackHorizontalGuide.segments[1].point = new Point(frame.right, botLeftPath.segments[1].point.y);
                botLeftBackVerticalGuide.strokeColor = backGuideColor;
                botLeftBackVerticalGuide.segments[0].point = new Point(botLeftPath.segments[1].point.x, frame.top);
                botLeftBackVerticalGuide.segments[1].point = new Point(botLeftPath.segments[1].point.x, frame.bottom);
            }
            if (botRightPath.segments[1].point != botRightPath.segments[0].point) {
                botRightBackHorizontalGuide.strokeColor = backGuideColor;
                botRightBackHorizontalGuide.segments[0].point = new Point(frame.left, botRightPath.segments[1].point.y);
                botRightBackHorizontalGuide.segments[1].point = new Point(frame.right, botRightPath.segments[1].point.y);
                botRightBackVerticalGuide.strokeColor = backGuideColor;
                botRightBackVerticalGuide.segments[0].point = new Point(botRightPath.segments[1].point.x, frame.top);
                botRightBackVerticalGuide.segments[1].point = new Point(botRightPath.segments[1].point.x, frame.bottom);
            }
            
            
        }
        function hideGuides() {
            topLeftPathGuide.strokeColor = "transparent";
            topRightPathGuide.strokeColor = "transparent";
            botLeftPathGuide.strokeColor = "transparent";
            botRightPathGuide.strokeColor = "transparent";
            topLeftBackHorizontalGuide.strokeColor = 'transparent';
            topLeftBackVerticalGuide.strokeColor = 'transparent';
            topRightBackHorizontalGuide.strokeColor = 'transparent';
            topRightBackVerticalGuide.strokeColor = 'transparent';
            botLeftBackHorizontalGuide.strokeColor = 'transparent';
            botLeftBackVerticalGuide.strokeColor = 'transparent';
            botRightBackHorizontalGuide.strokeColor = 'transparent';
            botRightBackVerticalGuide.strokeColor = 'transparent';
        }

        function drawBackLines() {

            if (topLeftPath.segments[1].point != topLeftPath.segments[0].point & topRightPath.segments[1].point != topRightPath.segments[0].point) {
                backTopPath.strokeColor = backPathColor;
                backTopPath.segments[0].point = topLeftPath.segments[1].point;
                backTopPath.segments[1].point = topRightPath.segments[1].point;
            }
            if (topRightPath.segments[1].point != topRightPath.segments[0].point & botRightPath.segments[1].point != botRightPath.segments[0].point) {
                backRightPath.strokeColor = backPathColor;
                backRightPath.segments[0].point = topRightPath.segments[1].point;
                backRightPath.segments[1].point = botRightPath.segments[1].point;
            }
            if (botRightPath.segments[1].point != botRightPath.segments[0].point & botLeftPath.segments[1].point != botLeftPath.segments[0].point) {
                backBotPath.strokeColor = backPathColor;
                backBotPath.segments[0].point = botRightPath.segments[1].point;
                backBotPath.segments[1].point = botLeftPath.segments[1].point;
            }
            if (topLeftPath.segments[1].point != topLeftPath.segments[0].point & botLeftPath.segments[1].point != botLeftPath.segments[0].point) {
                backLeftPath.strokeColor = backPathColor;
                backLeftPath.segments[0].point = botLeftPath.segments[1].point;
                backLeftPath.segments[1].point = topLeftPath.segments[1].point;
            }
        }

        function resetVertexStrokeWidth() {
            topLeftCircle.strokeWidth=0;
            topRightCircle.strokeWidth=0;
            botLeftCircle.strokeWidth=0;
            botRightCircle.strokeWidth=0;
        }

        function dist(p1, p2) {
            var delta = p1 - p2;
            return (Math.sqrt(Math.pow(delta.x,2) + Math.pow(delta.y,2)));
        }

        function hideAllTestPaths() {
            topLeftPathTest.strokeColor='transparent';
            topRightPathTest.strokeColor='transparent';
            botLeftPathTest.strokeColor='transparent';
            botRightPathTest.strokeColor='transparent';
        }

        function testAll() {
            var score = testTopLeftPath() +  testTopRightPath() + testBotLeftPath() + testBotRightPath();
            scoreValueText.content = score;
        }

        function testTopLeftPath() {
            var p1 = topLeftPath.segments[0].point;
            var p2 = topLeftPath.segments[1].point;
            topLeftPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            topLeftPathTest.segments[1].point.y = vp.y;
            topLeftPathTest.strokeColor='red';
            return Math.pow(vp.x - topLeftPathTest.segments[1].point.x,2);
        }
        function testTopRightPath() {
            var p1 = topRightPath.segments[0].point;
            var p2 = topRightPath.segments[1].point;
            topRightPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            topRightPathTest.segments[1].point.y = vp.y;
            topRightPathTest.strokeColor='red';
            return Math.pow(vp.x - topRightPathTest.segments[1].point.x,2);
        }
        function testBotLeftPath() {
            var p1 = botLeftPath.segments[0].point;
            var p2 = botLeftPath.segments[1].point;
            botLeftPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            botLeftPathTest.segments[1].point.y = vp.y;
            botLeftPathTest.strokeColor='red';
            return Math.pow(vp.x - botLeftPathTest.segments[1].point.x,2);
        }
        function testBotRightPath() {
            var p1 = botRightPath.segments[0].point;
            var p2 = botRightPath.segments[1].point;
            botRightPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            botRightPathTest.segments[1].point.y = vp.y;
            botRightPathTest.strokeColor='red';
            return Math.pow(vp.x - botRightPathTest.segments[1].point.x,2);
        }
        function randInt(min, max) {
            return Math.floor(Math.random() * (max - min) ) + min;
        }
    </script>
</head>
<body>
    <canvas id="canvas" resize></canvas>
</body>
</html>
