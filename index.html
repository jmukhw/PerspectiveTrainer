<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Perspective Trainer</title>
    <link rel="stylesheet" href="css/style.css">

    <script type="text/javascript" src="js/paper-full.min.js"></script>
    <script type="text/paperscript" canvas="canvas">

        /*
        TODO
        touch support
        back rectangle scoring
        variable difficulty via longer guide lines
        */
        var palette = ["#f2f0e5", //0 background
                       "#45444f", //1 frame stroke
                       "#4e584a", //2 rectangle stroke
                       "#c2d368", //3 rectangle fill
                       "#b8b5b9", //4 vanishing point stroke
                       "#b8b5b9", //5 vanishing point fill
                       "#b8b5b9", //6 horizon stroke
                       "#4e584a", //7 anchor stroke
                       "#4e584a", //8 anchor fill
                       "#8ab060", //9 anchor ring stroke
                       "#8ab060", //10 anchor ring fill
                       "#8ab060", //11 anchor ring clicked stroke
                       "#8ab060", //12 anchor ring clicked fill
                       "#8ab060", //13 box path stroke
                       "#8ab060", //14 box unacceptable path stroke
                       "#6d8c32", //15 back guide color
                       "#c2d368", //16 button hover fill color
                       "#8ab060", //17 button click fill color
                       "#b8b5b9", //18 button disabled fill color
                       "#EE6030", //19 Test Path Stroke
                       "#EE6030", //20 testPathArcStrokeColor
                       "#EE6030", //21 testScoreDecrementColor
                       "#45444f", //22 testScoreItemTotal
                       "#EE6030", //23 anchor selected color
                       "#EE6030", //24 new best score color
                       "#D2D0C5", //25 help panel background
                       "#D2E398"  //26 button default fill

                       ];

        var backgroundColor = palette[0]
        
        var frameStroke = palette[1];
        var frameFill = palette[0];
        var frameStrokeWidth = 3;
        var frameDashArray = [0];

        var rectStroke = palette[2];
        var rectFill = palette[3];
        var rectStrokeWidth = 2;
        var rectDashArray = [0];
        var rectStrokeAlpha = .75;
        var rectFillAlpha = .2;

        var vpStroke = palette[4];
        var vpFill = palette[5];
        var vpStrokeWidth = 1;
        var vpDashArray = [0];
        var vpStrokeAlpha = 1;
        var vpFillAlpha = 1;

        var horizonStroke = palette[6];
        var horizonStrokeWidth = 2;
        var horizonStrokeAlpha = .75;

        var anchorStroke = palette[7];
        var anchorFill = palette[8];
        var anchorStrokeWidth = 0;
        var anchorDashArray = [0];
        var anchorStrokeAlpha = .75;
        var anchorFillAlpha = 1;

        var anchorSelectedStroke = palette[23];
        var anchorSelectedFill = palette[23];

        var anchorRingRadius = 10;
        var anchorRingStroke = palette[9];
        var anchorRingFill = palette[10] + '00';
        var anchorRingStrokeWidth = 1;
        var anchorRingDashArray = [1,3];

        var anchorRingClickRadius = 13;
        var anchorRingClickStroke = palette[11];
        var anchorRingClickFill = palette[12] + '55';
        var anchorRingClickStrokeWidth = 1;
        var anchorRingClickDashArray = [1,3];
        var anchorRingClickTweenDuration = 200;

        var boxPathStroke = palette[13];
        var boxPathStrokeUnacceptable = palette[14];
        var boxPathStrokeWidth = 3;
        var boxPathDashArray = [5,5];
        var boxPathStrokeAlpha = .75;

        var guidePercent = .5;
        var pointDistPercent = .5;
        var rectSizeProp = .4;
        var rectSizePropVar = .35;

        var backGuideColor = palette[15];

        var buttonHoverFillColor = palette[16];
        var buttonClickFillColor = palette[17];
        var buttonDisabledFillColor = palette[18];

        var currentScore = 0;
        var nextEnabled = false;

        var testPathStrokeColor = palette[19];
        var testPathArcStrokeColor = palette[20];
        var testPathArcDashArray = [1,5];
        var testScoreDecrementColor = palette[21];
        var testScoreItemTotal = palette[22];
        var newBestScoreColor = palette[23];
        var helpPanelBackground = palette[25];
        var buttonDefaultFill = palette[26];

        var scoreAnimationSpeedMS = 2000;

        document.body.style.backgroundColor = backgroundColor;
        var path;
        var clickStartPoint = new Point(0,0);

        var frame = new Rectangle();
        var framePath = new Item();
        var framePathBottomText = new Item();
        var framePathTopText = new Item();
        var totalScore = 0;
        var nextButtonContainer = new Group();
        var rect = new Rectangle();
        var rectPath = new Path.Rectangle(rect);

        var vp = new Point(randInt(frame.left + 20,frame.right-20),randInt(frame.top+20, frame.bottom-20));
        var horizonPath = new Path();
        var vpCircle = new Path.Circle(vp, 3);
        var topLeftCircle = new Path.Circle(new Point(0, 0), 3);
        var topRightCircle = new Path.Circle(new Point(0, 0), 3);
        var botLeftCircle = new Path.Circle(new Point(0, 0), 3);
        var botRightCircle = new Path.Circle(new Point(0, 0), 3);

        var topLeftCircleRing = new Path.Circle({insert: false});
        var topLeftCircleRingClick = new Path.Circle({insert: false});
        var topLeftCircleRingUnclicked = new Path.Circle({insert: false});
        var topRightCircleRing = new Path.Circle({insert: false});
        var topRightCircleRingClick = new Path.Circle({insert: false});
        var topRightCircleRingUnclicked = new Path.Circle({insert: false});
        var botLeftCircleRing = new Path.Circle({insert: false});
        var botLeftCircleRingClick = new Path.Circle({insert: false});
        var botLeftCircleRingUnclicked = new Path.Circle({insert: false});
        var botRightCircleRing = new Path.Circle({insert: false});
        var botRightCircleRingClick = new Path.Circle({insert: false});
        var botRightCircleRingUnclicked = new Path.Circle({insert: false});

        var selectedVertex = "none";
        var activePath = "none";
        var topLeftPath = new Path();
        var topRightPath = new Path();
        var botLeftPath = new Path();
        var botRightPath = new Path();

        var topLeftPathTest = new Path();
        var topRightPathTest = new Path();
        var botLeftPathTest = new Path();
        var botRightPathTest = new Path();
        var topLeftPathGuide = new Path();
        var topRightPathGuide = new Path();
        var botLeftPathGuide = new Path();
        var botRightPathGuide = new Path();

        var backPathColor = 'grey';
        var backTopPath = new Path();
        var backLeftPath = new Path();
        var backRightPath = new Path();
        var backBotPath = new Path();

        var backGuideColor = backGuideColor;
        var backGuideArray = [3, 5];

        var topLeftBackHorizontalGuide = new Path();
        var topLeftBackVerticalGuide = new Path();
        var topRightBackHorizontalGuide = new Path();
        var topRightBackVerticalGuide = new Path();
        var botLeftBackHorizontalGuide = new Path();
        var botLeftBackVerticalGuide = new Path();
        var botRightBackHorizontalGuide = new Path();
        var botRightBackVerticalGuide = new Path();

        var testScoreTotalText = new Item();
        var testScoreDecrementText = new Item();
        var testPathAnimated = new Item();
        var testPathAnimated2 = new Item();
        var arc = new Item();
        var newRecordText = new Item();

        var helpButton = new Item();
        var helpButtonText = new Item();
        var helpButtonContainer = new Item();
        var helpPanel = new Item();
        var helpPanelText = new Item();
        var helpPanelContainer = new Item();

        var bestScore = 0;

        var randDistScale = 1;

        initialize(10, 1);

        function initialize(difficulty, round) {
            newRecordText.remove();
            totalScore = 0;
            guidePercent = .3-((difficulty-1)/9)*.3;
            backGuideColor = '#333E55' + Math.abs(difficulty - 10) + '0';

            

            frame = new Rectangle();
            frame.left = 30;
            frame.right = window.innerWidth-30;
            frame.top = 60;
            frame.bottom = window.innerHeight-50;

            framePath.remove();
            
            framePath = new CompoundPath({ children: [
                new Path(new Point(frame.left, frame.top-20), new Point(frame.left + (frame.right-frame.left)/2-(frame.right-frame.left)/4, frame.top-20)),
                new Path(new Point(frame.left + (frame.right-frame.left)/2+(frame.right-frame.left)/4, frame.top-20), new Point(frame.right-50, frame.top-20)),
                new Path(new Point(frame.right-20, frame.top-20), new Point(frame.right, frame.top-20)),
                new Path.Rectangle({
                    topLeft: [frame.left + (frame.right-frame.left)/2-(frame.right-frame.left)/4, frame.top-50],
                    bottomRight: [frame.left + (frame.right-frame.left)/2+(frame.right-frame.left)/4, frame.top],
                    radius: 10}),
                new Path(new Point(frame.left, frame.bottom+20), new Point(frame.left + (frame.right-frame.left)/2-30, frame.bottom+20)),
                new Path(new Point((frame.right-frame.left)/2+30, frame.bottom+20), new Point(frame.right, frame.bottom+20))
                ],
                fillColor: backgroundColor,
                strokeColor: frameStroke,
                strokeWidth: frameStrokeWidth,
                dashArray: frameDashArray
            });

            nextButton = new Path.Rectangle({
                topLeft: [frame.left + (frame.right-frame.left)/2-30, frame.bottom],
                    bottomRight: [frame.left + (frame.right-frame.left)/2+30, frame.bottom+40],
                    radius: 10,
                    fillColor: buttonDefaultFill,
                    strokeColor: frameStroke,
                    strokeWidth: frameStrokeWidth,
                    dashArray: frameDashArray})

            helpButton = new Path.Rectangle({
                topLeft: [frame.right - 50, frame.top-40],
                    bottomRight: [frame.right - 20, frame.top-5],
                    radius: 10,
                    fillColor: buttonDefaultFill,
                    strokeColor: frameStroke,
                    strokeWidth: frameStrokeWidth,
                    dashArray: frameDashArray})
            helpButtonText.remove();
            helpButtonText = new PointText({point: new Point(frame.right - 35, frame.top - 15), content: "?", fillColor : frameStroke, justification: "center", fontSize: 18, fontFamily: 'Georgia, serif', fontWeight: '1000'});
            helpButtonContainer.remove();
            helpButtonContainer = new Group();
            helpButtonContainer.addChild(helpButton);
            helpButtonContainer.addChild(helpButtonText);

            helpButtonContainer.on('mouseenter', function() { this.firstChild.fillColor=buttonHoverFillColor});
            helpButtonContainer.on('mouseleave', function() { this.firstChild.fillColor=buttonDefaultFill});
            helpButtonContainer.on('mousedown', function() { this.firstChild.fillColor = buttonClickFillColor; setHelpPanelVisible(true)});
            helpButtonContainer.on('mouseup', function() { this.firstChild.fillColor = buttonDefaultFill; setHelpPanelVisible(false)});

            helpPanelText.remove();
            helpPanelText = new PointText({point: new Point(frame.left + (frame.right-frame.left)/2, frame.top + (frame.bottom-frame.top)/2), fillColor : frameStroke, justification: "center", fontSize: 20, fontFamily: 'Georgia, serif', fontWeight: '1000'});
            helpPanelText.content = "Select each of the corners of the box\nand drag toward the vanishing point.\nOnce a corner is selected you can\npress anywhere to start dragging it.\n" +
            "\n Once you've positioned all four back\nvertices in proper 1-point perspective,\npress the button at the bottom to see\nhow well you did."

            helpPanel.remove();
            helpPanel = new Path.Rectangle({
                topLeft: [helpPanelText.point.x-helpPanelText.bounds.width/2-20, helpPanelText.point.y-40],
                    bottomRight: [helpPanelText.point.x+helpPanelText.bounds.width/2+20, helpPanelText.point.y+helpPanelText.bounds.height],
                    radius: 10,
                    fillColor: helpPanelBackground,
                    strokeColor: frameStroke,
                    strokeWidth: frameStrokeWidth,
                    dashArray: frameDashArray});
            
            helpPanelContainer.remove();
            helpPanelContainer = new Group();
            helpPanelContainer.addChild(helpPanel);
            helpPanelContainer.addChild(helpPanelText);
            helpPanelContainer.opacity = 0;


            framePathTopText.remove();
            framePathBottomText.remove();
            framePathTopText = new PointText({point: new Point(frame.left + (frame.right-frame.left)/2, frame.top-30), content: "Score: 0", fillColor : frameStroke, justification: "center", fontSize: 20, fontFamily: 'Georgia, serif', fontWeight: '1000'});
            framePathBottomText = new PointText({point: new Point(frame.left + (frame.right-frame.left)/2, frame.top-10), content: "Best: " + bestScore, fillColor : frameStroke, justification: "center", fontSize: 12, fontFamily: 'Georgia, serif', fontWeight: '100'});
            framePathNextText = new PointText({point: new Point(frame.left + (frame.right-frame.left)/2, frame.bottom+25), content: "▶", fillColor : frameStroke, justification: "center", fontSize: 18, fontFamily: 'Georgia, serif', fontWeight: '1000'});

            nextButtonContainer.remove();
            nextButtonContainer = new Group();
            nextButtonContainer.addChild(nextButton);
            nextButtonContainer.addChild(framePathNextText);

            nextButtonContainer.on('mouseenter', function() { if (!nextEnabled) return; this.firstChild.fillColor=buttonHoverFillColor});
            nextButtonContainer.on('mouseleave', function() {if (!nextEnabled) return; this.firstChild.fillColor=buttonDefaultFill});
            nextButtonContainer.on('mousedown', function() { if (!nextEnabled) return; this.firstChild.fillColor = buttonClickFillColor; testAll();  });
            nextButtonContainer.on('mouseup', function() {if (!nextEnabled) return;  this.firstChild.fillColor = buttonDefaultFill; });
            nextButtonContainer.on('frame', function() {
                if ((topLeftPath.segments[1].point != topLeftPath.segments[0].point) &
                    (topRightPath.segments[1].point != topRightPath.segments[0].point) &
                    (botLeftPath.segments[1].point != botLeftPath.segments[0].point) &
                    (botRightPath.segments[1].point != botRightPath.segments[0].point) &
                    nextEnabled == false) {
                    nextEnabled = true; 
                    this.firstChild.fillColor=buttonDefaultFill;
                } else if (nextEnabled == false) {
                    this.firstChild.fillColor=buttonDisabledFillColor;
                } 
            });
            vp = new Point(randInt(frame.left + 50,frame.right-50),randInt(frame.top+50, frame.bottom-50));
            //new Path.Circle({center: [20,20], radius: 10, fillColor: palette[2]}).onMouseUp = testTopLeftPath;
            rect.left=rect.right=rect.top=rect.bottom=0;

            var c = 0;
            while (((rect.right-rect.left)<100 |
                   (rect.bottom-rect.top)<100 |
                   Math.abs(rect.left-vp.x)<50 |
                   Math.abs(rect.right-vp.x)<50 |
                   Math.abs(rect.top-vp.y)<50 |
                   Math.abs(rect.bottom-vp.y)<50) &
                   c < 100) {
                c++;       
                rect.left = randInt(frame.left+20, frame.right-(frame.right-frame.left)*(rectSizeProp+rectSizePropVar)-30);
                rect.right = rect.left + randInt((frame.right-frame.left)*(rectSizeProp-rectSizePropVar), (frame.right-frame.left)*(rectSizeProp+rectSizePropVar));
                rect.top = randInt(frame.top+20, frame.bottom-(frame.bottom-frame.top)*(rectSizeProp+rectSizePropVar)-30);
                rect.bottom = rect.top + randInt((frame.bottom-frame.top)*(rectSizeProp-rectSizePropVar), (frame.bottom-frame.top)*(rectSizeProp+rectSizePropVar));
            }
            
            rectPath.remove();
            rectPath = new Path.Rectangle(rect);
            
            rectPath.strokeColor=rectStroke;
            rectPath.fillColor=rectFill;
            rectPath.strokeWidth=rectStrokeWidth;
            rectPath.dashArray=rectDashArray;
            rectPath.fillColor.alpha = rectFillAlpha;
            rectPath.strokeColor.alpha = rectStrokeAlpha;

            

            horizonPath.remove();
            horizonPath = new Path();
            horizonPath.strokeColor=horizonStroke;
            horizonPath.strokeWidth=horizonStrokeWidth;
            horizonPath.strokeColor.alpha=horizonStrokeAlpha;
            horizonPath.add(new Point(frame.left, vp.y), new Point(frame.right, vp.y));

            vpCircle.remove();
            vpCircle = new Path.Circle(vp, 3);
            
            vpCircle.strokeColor=vpStroke;
            vpCircle.fillColor=vpFill;
            vpCircle.strokeWidth=vpStrokeWidth;
            vpCircle.dashArray=vpDashArray;
            vpCircle.strokeColor.alpha = vpStrokeAlpha;
            vpCircle.fillColor.alpha = vpFillAlpha;

            topLeftCircle.remove();
            topLeftCircle = new Path.Circle(new Point(0, 0), 5);
            topLeftCircle.position = new Point(rect.left, rect.top);
            topLeftCircle.fillColor=anchorFill;
            topLeftCircle.fillColor.alpha=anchorFillAlpha;
            topLeftCircle.strokeColor=anchorStroke;
            topLeftCircle.strokeColor.alpha=anchorStrokeAlpha;
            topLeftCircle.strokeWidth=anchorStrokeWidth;
            topLeftCircle.dashArray = anchorDashArray;

            topLeftCircle.on('mouseenter', function() {this.scale(1.5)});
            topLeftCircle.on('mouseleave', function() {this.scale(1/1.5)});

            topLeftCircleRing.remove();
            topLeftCircleRing = new Path.Circle({position: new Point(rect.left, rect.top), 
                                                 radius: anchorRingRadius,
                                                 fillColor: anchorRingFill,
                                                 strokeColor:anchorRingStroke,
                                                 strokeWidth:anchorRingStrokeWidth,
                                                 dashArray : anchorRingDashArray
                                                });
            topLeftCircleRingUnclicked = topLeftCircleRing.clone({insert: false});

            topLeftCircleRingClick = new Path.Circle({position: new Point(rect.left, rect.top), 
                                                 radius: anchorRingClickRadius,
                                                 fillColor: anchorRingClickFill,
                                                 strokeColor:anchorRingClickStroke,
                                                 strokeWidth:anchorRingClickStrokeWidth,
                                                 dashArray : anchorRingClickDashArray,
                                                 insert: false
                                                });

            topRightCircle.remove();
            topRightCircle = new Path.Circle(new Point(0, 0), 5);
            topRightCircle.position = new Point(rect.right, rect.top);
            topRightCircle.fillColor=anchorFill;
            topRightCircle.fillColor.alpha=anchorFillAlpha;
            topRightCircle.strokeColor=anchorStroke;
            topRightCircle.strokeColor.alpha=anchorStrokeAlpha;
            topRightCircle.strokeWidth=anchorStrokeWidth;
            topRightCircle.dashArray = anchorDashArray;

            topRightCircle.on('mouseenter', function() {this.scale(1.5)});
            topRightCircle.on('mouseleave', function() {this.scale(1/1.5)});

            topRightCircleRing.remove();
            topRightCircleRing = new Path.Circle({position: new Point(rect.right, rect.top), 
                                                 radius: anchorRingRadius,
                                                 fillColor: anchorRingFill,
                                                 strokeColor:anchorRingStroke,
                                                 strokeWidth:anchorRingStrokeWidth,
                                                 dashArray : anchorRingDashArray
                                                });
            topRightCircleRingUnclicked = topRightCircleRing.clone({insert: false});

            topRightCircleRingClick = new Path.Circle({position: new Point(rect.right, rect.top), 
                                                 radius: anchorRingClickRadius,
                                                 fillColor: anchorRingClickFill,
                                                 strokeColor:anchorRingClickStroke,
                                                 strokeWidth:anchorRingClickStrokeWidth,
                                                 dashArray : anchorRingClickDashArray,
                                                 insert: false
                                                });

            botLeftCircle.remove();
            botLeftCircle = new Path.Circle(new Point(0, 0), 5);
            botLeftCircle.position = new Point(rect.left, rect.bottom);
            botLeftCircle.fillColor=anchorFill;
            botLeftCircle.fillColor.alpha=anchorFillAlpha;
            botLeftCircle.strokeColor=anchorStroke;
            botLeftCircle.strokeColor.alpha=anchorStrokeAlpha;
            botLeftCircle.strokeWidth=anchorStrokeWidth;
            botLeftCircle.dashArray = anchorDashArray;

            botLeftCircle.on('mouseenter', function() {this.scale(1.5)});
            botLeftCircle.on('mouseleave', function() {this.scale(1/1.5)});

            botLeftCircleRing.remove();
            botLeftCircleRing = new Path.Circle({position: new Point(rect.left, rect.bottom), 
                                                 radius: anchorRingRadius,
                                                 fillColor: anchorRingFill,
                                                 strokeColor:anchorRingStroke,
                                                 strokeWidth:anchorRingStrokeWidth,
                                                 dashArray : anchorRingDashArray
                                                });
            botLeftCircleRingUnclicked = botLeftCircleRing.clone({insert: false});

            botLeftCircleRingClick = new Path.Circle({position: new Point(rect.left, rect.bottom), 
                                                 radius: anchorRingClickRadius,
                                                 fillColor: anchorRingClickFill,
                                                 strokeColor:anchorRingClickStroke,
                                                 strokeWidth:anchorRingClickStrokeWidth,
                                                 dashArray : anchorRingClickDashArray,
                                                 insert: false
                                                });

            botRightCircle.remove();
            botRightCircle = new Path.Circle(new Point(0, 0), 5);
            botRightCircle.position = new Point(rect.right, rect.bottom);
            botRightCircle.fillColor=anchorFill;
            botRightCircle.fillColor.alpha=anchorFillAlpha;
            botRightCircle.strokeColor=anchorStroke;
            botRightCircle.strokeColor.alpha=anchorStrokeAlpha;
            botRightCircle.strokeWidth=anchorStrokeWidth;
            botRightCircle.dashArray = anchorDashArray;

            botRightCircle.on('mouseenter', function() {this.scale(1.5)});
            botRightCircle.on('mouseleave', function() {this.scale(1/1.5)});

            botRightCircleRing.remove();
            botRightCircleRing = new Path.Circle({position: new Point(rect.right, rect.bottom), 
                                                 radius: anchorRingRadius,
                                                 fillColor: anchorRingFill,
                                                 strokeColor:anchorRingStroke,
                                                 strokeWidth:anchorRingStrokeWidth,
                                                 dashArray : anchorRingDashArray
                                                });
            botRightCircleRingUnclicked = botRightCircleRing.clone({insert: false});

            botRightCircleRingClick = new Path.Circle({position: new Point(rect.right, rect.bottom), 
                                                 radius: anchorRingClickRadius,
                                                 fillColor: anchorRingClickFill,
                                                 strokeColor:anchorRingClickStroke,
                                                 strokeWidth:anchorRingClickStrokeWidth,
                                                 dashArray : anchorRingClickDashArray,
                                                 insert: false
                                                });

            selectedVertex = "none";
            activePath = "none";

            topLeftPath.remove();
            topLeftPath = new Path();
            topLeftPath.insertBelow(topLeftCircle);
            topLeftPath.add(new Point(rect.left, rect.top), new Point(rect.left, rect.top));
            topLeftPath.strokeColor = boxPathStroke;
            topLeftPath.strokeWidth = boxPathStrokeWidth;
            topLeftPath.dashArray = boxPathDashArray;
            topLeftPath.strokeColor.alpha = boxPathStrokeAlpha;

            topRightPath.remove();
            topRightPath = new Path();
            topRightPath.insertBelow(topRightCircle);
            topRightPath.add(new Point(rect.right, rect.top), new Point(rect.right, rect.top));
            topRightPath.strokeColor = boxPathStroke;
            topRightPath.strokeWidth = boxPathStrokeWidth;
            topRightPath.dashArray = boxPathDashArray;
            topRightPath.strokeColor.alpha = boxPathStrokeAlpha;

            botLeftPath.remove();
            botLeftPath = new Path();
            botLeftPath.insertBelow(botLeftCircle);
            botLeftPath.add(new Point(rect.left, rect.bottom), new Point(rect.left, rect.bottom));
            botLeftPath.strokeColor = boxPathStroke;
            botLeftPath.strokeWidth = boxPathStrokeWidth;
            botLeftPath.dashArray = boxPathDashArray;
            botLeftPath.strokeColor.alpha = boxPathStrokeAlpha;

            botRightPath.remove();
            botRightPath = new Path();
            botRightPath.insertBelow(botRightCircle);
            botRightPath.add(new Point(rect.right, rect.bottom), new Point(rect.right, rect.bottom));
            botRightPath.strokeColor = boxPathStroke;
            botRightPath.strokeWidth = boxPathStrokeWidth;
            botRightPath.dashArray = boxPathDashArray;
            botRightPath.strokeColor.alpha = boxPathStrokeAlpha;

            topLeftPathTest.remove();
            topLeftPathTest = new Path();
            topLeftPathTest.strokeColor = 'transparent';
            topLeftPathTest.add(new Point(rect.left, rect.top));
            topLeftPathTest.add(vp);
            
            topRightPathTest.remove();
            topRightPathTest = new Path();
            topRightPathTest.strokeColor = 'transparent';
            topRightPathTest.add(new Point(rect.right, rect.top));
            topRightPathTest.add(vp);

            botLeftPathTest.remove();
            botLeftPathTest = new Path();
            botLeftPathTest.strokeColor = 'transparent';
            botLeftPathTest.add(new Point(rect.left, rect.bottom));
            botLeftPathTest.add(vp);

            botRightPathTest.remove();
            botRightPathTest = new Path();
            botRightPathTest.strokeColor = 'transparent';
            botRightPathTest.add(new Point(rect.right, rect.bottom));
            botRightPathTest.add(vp);

            topLeftPathGuide.remove();
            topLeftPathGuide = new Path();
            topLeftPathGuide.strokeColor = 'transparent';
            topLeftPathGuide.add(new Point(rect.left, rect.top));
            topLeftPathGuide.add(vp);
            
            topRightPathGuide.remove();
            topRightPathGuide = new Path();
            topRightPathGuide.strokeColor = 'transparent';
            topRightPathGuide.add(new Point(rect.right, rect.top));
            topRightPathGuide.add(vp);

            botLeftPathGuide.remove();
            botLeftPathGuide = new Path();
            botLeftPathGuide.strokeColor = 'transparent';
            botLeftPathGuide.add(new Point(rect.left, rect.bottom));
            botLeftPathGuide.add(vp);

            botRightPathGuide.remove();
            botRightPathGuide = new Path();
            botRightPathGuide.strokeColor = 'transparent';
            botRightPathGuide.add(new Point(rect.right, rect.bottom));
            botRightPathGuide.add(vp);


            backTopPath.remove();
            backTopPath = new Path();
            backTopPath.strokeColor = 'trasparent';
            backTopPath.add(new Point(0,0), new Point(0,0));
            backLeftPath.remove();
            backLeftPath = new Path();
            backLeftPath.strokeColor = 'trasparent';
            backLeftPath.add(new Point(0,0), new Point(0,0));
            backRightPath.remove();
            backRightPath = new Path();
            backRightPath.strokeColor = 'trasparent';
            backRightPath.add(new Point(0,0), new Point(0,0));
            backBotPath.remove();
            backBotPath = new Path();
            backBotPath.strokeColor = 'trasparent';
            backBotPath.add(new Point(0,0), new Point(0,0));


            topLeftBackHorizontalGuide = new Path();
            topLeftBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
            topLeftBackHorizontalGuide.strokeColor = backGuideColor;
            topLeftBackHorizontalGuide.dashArray = backGuideArray;
            topLeftBackVerticalGuide = new Path();
            topLeftBackVerticalGuide.add(new Point(0,0), new Point(0,0));
            topLeftBackVerticalGuide.strokeColor = backGuideColor;
            topLeftBackVerticalGuide.dashArray = backGuideArray;
            topRightBackHorizontalGuide = new Path();
            topRightBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
            topRightBackHorizontalGuide.strokeColor = backGuideColor;
            topRightBackHorizontalGuide.dashArray = backGuideArray;
            topRightBackVerticalGuide = new Path();
            topRightBackVerticalGuide.add(new Point(0,0), new Point(0,0));
            topRightBackVerticalGuide.strokeColor = backGuideColor;
            topRightBackVerticalGuide.dashArray = backGuideArray;
            botLeftBackHorizontalGuide = new Path();
            botLeftBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
            botLeftBackHorizontalGuide.strokeColor = backGuideColor;
            botLeftBackHorizontalGuide.dashArray = backGuideArray;
            botLeftBackVerticalGuide = new Path();
            botLeftBackVerticalGuide.add(new Point(0,0), new Point(0,0));
            botLeftBackVerticalGuide.strokeColor = backGuideColor;
            botLeftBackVerticalGuide.dashArray = backGuideArray;
            botRightBackHorizontalGuide = new Path();
            botRightBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
            botRightBackHorizontalGuide.strokeColor = backGuideColor;
            botRightBackHorizontalGuide.dashArray = backGuideArray;
            botRightBackVerticalGuide = new Path();
            botRightBackVerticalGuide.add(new Point(0,0), new Point(0,0));
            botRightBackVerticalGuide.strokeColor = backGuideColor;
            botRightBackVerticalGuide.dashArray = backGuideArray;
            



        }

        function setHelpPanelVisible(visibilityBool) {
            if (visibilityBool) {
                helpPanelContainer.bringToFront();
                helpPanelContainer.opacity = 1;
            } else {
                helpPanelContainer.opacity = 0;
            }
        }


        function onMouseDrag(event) {
            var cursorpoint = event.point;
            if (event.point.x < frame.left) return;
            if (event.point.x > frame.right) return;
            if (event.point.y < frame.top) return;
            if (event.point.y > frame.bottom) return;

            if (activePath == "none") return;

            if (activePath == "topLeft") {
                cursorpoint = topLeftPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, topLeftPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(topLeftPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = topLeftPath.segments[0].point.x + (cursorpoint.x - topLeftPath.segments[0].point.x)/scalingFactor;
                var y = topLeftPath.segments[0].point.y + (cursorpoint.y - topLeftPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    topLeftPath.strokeColor = boxPathStrokeUnacceptable;
                } else {
                    topLeftPath.strokeColor = boxPathStroke;

                    topLeftPath.segments[1].point.x = x;
                    topLeftPath.segments[1].point.y = y;
    
                    topLeftCircle.position = new Point(x, y);
                }
            } else if (activePath == "topRight") {
                cursorpoint = topRightPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, topRightPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(topRightPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = topRightPath.segments[0].point.x + (cursorpoint.x - topRightPath.segments[0].point.x)/scalingFactor;
                var y = topRightPath.segments[0].point.y + (cursorpoint.y - topRightPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    topRightPath.strokeColor = boxPathStrokeUnacceptable;
                } else {
                    topRightPath.strokeColor = boxPathStroke;

                    topRightPath.segments[1].point.x = x;
                    topRightPath.segments[1].point.y = y;
    
                    topRightCircle.position = new Point(x, y);
                }
            } else if (activePath == "botLeft") {
                cursorpoint = botLeftPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, botLeftPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(botLeftPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = botLeftPath.segments[0].point.x + (cursorpoint.x - botLeftPath.segments[0].point.x)/scalingFactor;
                var y = botLeftPath.segments[0].point.y + (cursorpoint.y - botLeftPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    botLeftPath.strokeColor = boxPathStroke;
                } else {
                    botLeftPath.strokeColor = boxPathStroke;

                    botLeftPath.segments[1].point.x = x;
                    botLeftPath.segments[1].point.y = y;
    
                    botLeftCircle.position = new Point(x, y);
                }
            } else if (activePath == "botRight") {
                cursorpoint = botRightPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, botRightPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(botRightPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = botRightPath.segments[0].point.x + (cursorpoint.x - botRightPath.segments[0].point.x)/scalingFactor;
                var y = botRightPath.segments[0].point.y + (cursorpoint.y - botRightPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    botRightPath.strokeColor = boxPathStroke;
                } else {
                    botRightPath.strokeColor = boxPathStroke;

                    botRightPath.segments[1].point.x = x;
                    botRightPath.segments[1].point.y = y;
    
                    botRightCircle.position = new Point(x, y);
                }
            }
            showGuides();
        }
        
        function onMouseDown(event) {

            if (event.point.x < frame.left) return;
            if (event.point.x > frame.right) return;
            if (event.point.y < frame.top) return;
            if (event.point.y > frame.bottom) return;

            selectVertex(event);
            randDistScale = randInt(100,140)/100;
            if (selectedVertex == "none") {
                return;
            }
            hideAllTestPaths();
            clickStartPoint = event.point;
            
            
            if (selectedVertex == "topLeft") {  
                topLeftPath.segments[0].point = new Point(rect.left, rect.top);
                activePath = "topLeft";
                
                backLeftPath.strokeColor = 'transparent';
                backTopPath.strokeColor = 'transparent';

            } else if (selectedVertex == "topRight") {  
                topRightPath.segments[0].point = new Point(rect.right, rect.top);
                activePath = "topRight";
                topRightPath.strokeColor='transparent';
                
                backRightPath.strokeColor = 'transparent';
                backTopPath.strokeColor = 'transparent';
            } else if (selectedVertex == "botLeft") {  
                botLeftPath.segments[0].point = new Point(rect.left, rect.bottom);
                activePath = "botLeft";
                botLeftPath.strokeColor='transparent';

                backLeftPath.strokeColor = 'transparent';
                backBotPath.strokeColor = 'transparent';
            } else if (selectedVertex == "botRight") {  
                botRightPath.segments[0].point = new Point(rect.right, rect.bottom);
                activePath = "botRight";
                botRightPath.strokeColor='transparent';

                backRightPath.strokeColor = 'transparent';
                backBotPath.strokeColor = 'transparent';
            }
        }

        function selectVertex(event) {
            var grabDist = 40;
            var circleGrowWidth = 5;

            if (dist(event.point, topLeftCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                selectedVertex = "topLeft";
                topLeftCircle.strokeColor = topLeftCircle.fillColor = anchorSelectedFill;

                changeAnchorRing(topLeftCircleRing, topLeftCircleRingClick);
            } else if (dist(event.point, topRightCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                topRightCircle.strokeColor = topRightCircle.fillColor = anchorSelectedFill;
                selectedVertex = "topRight";

            } else if (dist(event.point, botLeftCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                selectedVertex = "botLeft";
                botLeftCircle.strokeColor = botLeftCircle.fillColor = anchorSelectedFill;
            } else if (dist(event.point, botRightCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                selectedVertex = "botRight";
                botRightCircle.strokeColor = botRightCircle.fillColor = anchorSelectedFill;

            } else if (event.point.x < frame.left | event.point.x > frame.right | event.point.y < frame.top | event.point.y > frame.bottom) {
                selectedVertex = "none";
                resetVertexStrokeWidth();
            }
        }

        function changeAnchorRing(path, pathTo) {
            var pathFrom = path.clone({insert: false});
            path.tween(anchorRingClickTweenDuration).onUpdate = function(event) {
                var d = Math.pow(event.factor, .25);
                path.interpolate(pathFrom, pathTo, d);  
                path.fillColor = pathFrom.fillColor*(1-d) + pathTo.fillColor*d;
                path.fillColor.alpha = pathFrom.fillColor.alpha*(1-d) + pathTo.fillColor.alpha*d;

            }
        }

        function onMouseUp(event) {
            if (activePath == "topLeft") {
                topLeftPath.strokeColor = boxPathStroke;
                changeAnchorRing(topLeftCircleRing, topLeftCircleRingUnclicked);
            } else if (activePath == "topRight") {
                topRightPath.strokeColor = boxPathStroke;
                changeAnchorRing(topRightCircleRing, topRightCircleRingUnclicked);
            } else if (activePath == "botLeft"){
                botLeftPath.strokeColor = boxPathStroke;
                changeAnchorRing(botLeftCircleRing, botLeftCircleRingUnclicked);
            } else if (activePath == "botRight") {
                botRightPath.strokeColor = boxPathStroke;
                changeAnchorRing(botRightCircleRing, botRightCircleRingUnclicked);
            }
            
            topLeftCircle.position = new Point(rect.left, rect.top);
            topRightCircle.position = new Point(rect.right, rect.top);
            botLeftCircle.position = new Point(rect.left, rect.bottom);
            botRightCircle.position = new Point(rect.right, rect.bottom);
            drawBackLines();
            hideGuides();
        }
        function clamp(min, max, v) {
            return Math.min(max, Math.max(min, v));
        }

        function showGuides(event) {
            if (activePath == "topLeft") {
                topLeftPathGuide.strokeColor = "blue";
                topLeftPathGuide.dashArray = [2,4];

                topLeftPathGuide.segments[0].point.x = topLeftPath.segments[1].point.x;
                topLeftPathGuide.segments[0].point.y = topLeftPath.segments[1].point.y;

                var p1 = topLeftPath.segments[0].point;
                var p2 = topLeftPath.segments[1].point;

                var targety = topLeftPathGuide.segments[0].point.y + (vp.y - topLeftPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                topLeftPathGuide.segments[1].point.x = xclamped;
                topLeftPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;

            } else if (activePath == "topRight") {
                topRightPathGuide.strokeColor = "blue";
                topRightPathGuide.dashArray = [2,4];

                topRightPathGuide.segments[0].point.x = topRightPath.segments[1].point.x;
                topRightPathGuide.segments[0].point.y = topRightPath.segments[1].point.y;

                var p1 = topRightPath.segments[0].point;
                var p2 = topRightPath.segments[1].point;

                var targety = topRightPathGuide.segments[0].point.y + (vp.y - topRightPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                topRightPathGuide.segments[1].point.x = xclamped;
                topRightPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;

            } else if (activePath == "botLeft") {
                botLeftPathGuide.strokeColor = "blue";
                botLeftPathGuide.dashArray = [2,4];

                botLeftPathGuide.segments[0].point.x = botLeftPath.segments[1].point.x;
                botLeftPathGuide.segments[0].point.y = botLeftPath.segments[1].point.y;

                var p1 = botLeftPath.segments[0].point;
                var p2 = botLeftPath.segments[1].point;

                var targety = botLeftPathGuide.segments[0].point.y + (vp.y - botLeftPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                botLeftPathGuide.segments[1].point.x = xclamped;
                botLeftPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;

            } else if (activePath == "botRight") {
                botRightPathGuide.strokeColor = "blue";
                botRightPathGuide.dashArray = [2,4];

                botRightPathGuide.segments[0].point.x = botRightPath.segments[1].point.x;
                botRightPathGuide.segments[0].point.y = botRightPath.segments[1].point.y;

                var p1 = botRightPath.segments[0].point;
                var p2 = botRightPath.segments[1].point;

                var targety = botRightPathGuide.segments[0].point.y + (vp.y - botRightPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                botRightPathGuide.segments[1].point.x = xclamped;
                botRightPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;
            }

            if (topLeftPath.segments[1].point != topLeftPath.segments[0].point) {
                topLeftBackHorizontalGuide.strokeColor = backGuideColor;
                topLeftBackHorizontalGuide.segments[0].point = new Point(frame.left, topLeftPath.segments[1].point.y);
                topLeftBackHorizontalGuide.segments[1].point = new Point(frame.right, topLeftPath.segments[1].point.y);
                topLeftBackVerticalGuide.strokeColor = backGuideColor;
                topLeftBackVerticalGuide.segments[0].point = new Point(topLeftPath.segments[1].point.x, frame.top);
                topLeftBackVerticalGuide.segments[1].point = new Point(topLeftPath.segments[1].point.x, frame.bottom);
            }
            if (topRightPath.segments[1].point != topRightPath.segments[0].point) {
                topRightBackHorizontalGuide.strokeColor = backGuideColor;
                topRightBackHorizontalGuide.segments[0].point = new Point(frame.left, topRightPath.segments[1].point.y);
                topRightBackHorizontalGuide.segments[1].point = new Point(frame.right, topRightPath.segments[1].point.y);
                topRightBackVerticalGuide.strokeColor = backGuideColor;
                topRightBackVerticalGuide.segments[0].point = new Point(topRightPath.segments[1].point.x, frame.top);
                topRightBackVerticalGuide.segments[1].point = new Point(topRightPath.segments[1].point.x, frame.bottom);
            }
            if (botLeftPath.segments[1].point != botLeftPath.segments[0].point) {
                botLeftBackHorizontalGuide.strokeColor = backGuideColor;
                botLeftBackHorizontalGuide.segments[0].point = new Point(frame.left, botLeftPath.segments[1].point.y);
                botLeftBackHorizontalGuide.segments[1].point = new Point(frame.right, botLeftPath.segments[1].point.y);
                botLeftBackVerticalGuide.strokeColor = backGuideColor;
                botLeftBackVerticalGuide.segments[0].point = new Point(botLeftPath.segments[1].point.x, frame.top);
                botLeftBackVerticalGuide.segments[1].point = new Point(botLeftPath.segments[1].point.x, frame.bottom);
            }
            if (botRightPath.segments[1].point != botRightPath.segments[0].point) {
                botRightBackHorizontalGuide.strokeColor = backGuideColor;
                botRightBackHorizontalGuide.segments[0].point = new Point(frame.left, botRightPath.segments[1].point.y);
                botRightBackHorizontalGuide.segments[1].point = new Point(frame.right, botRightPath.segments[1].point.y);
                botRightBackVerticalGuide.strokeColor = backGuideColor;
                botRightBackVerticalGuide.segments[0].point = new Point(botRightPath.segments[1].point.x, frame.top);
                botRightBackVerticalGuide.segments[1].point = new Point(botRightPath.segments[1].point.x, frame.bottom);
            }
            
            
        }
        function hideGuides() {
            topLeftPathGuide.strokeColor = "transparent";
            topRightPathGuide.strokeColor = "transparent";
            botLeftPathGuide.strokeColor = "transparent";
            botRightPathGuide.strokeColor = "transparent";
            topLeftBackHorizontalGuide.strokeColor = 'transparent';
            topLeftBackVerticalGuide.strokeColor = 'transparent';
            topRightBackHorizontalGuide.strokeColor = 'transparent';
            topRightBackVerticalGuide.strokeColor = 'transparent';
            botLeftBackHorizontalGuide.strokeColor = 'transparent';
            botLeftBackVerticalGuide.strokeColor = 'transparent';
            botRightBackHorizontalGuide.strokeColor = 'transparent';
            botRightBackVerticalGuide.strokeColor = 'transparent';
        }

        function drawBackLines() {

            if (topLeftPath.segments[1].point != topLeftPath.segments[0].point & topRightPath.segments[1].point != topRightPath.segments[0].point) {
                backTopPath.strokeColor = backPathColor;
                backTopPath.segments[0].point = topLeftPath.segments[1].point;
                backTopPath.segments[1].point = topRightPath.segments[1].point;
            }
            if (topRightPath.segments[1].point != topRightPath.segments[0].point & botRightPath.segments[1].point != botRightPath.segments[0].point) {
                backRightPath.strokeColor = backPathColor;
                backRightPath.segments[0].point = topRightPath.segments[1].point;
                backRightPath.segments[1].point = botRightPath.segments[1].point;
            }
            if (botRightPath.segments[1].point != botRightPath.segments[0].point & botLeftPath.segments[1].point != botLeftPath.segments[0].point) {
                backBotPath.strokeColor = backPathColor;
                backBotPath.segments[0].point = botRightPath.segments[1].point;
                backBotPath.segments[1].point = botLeftPath.segments[1].point;
            }
            if (topLeftPath.segments[1].point != topLeftPath.segments[0].point & botLeftPath.segments[1].point != botLeftPath.segments[0].point) {
                backLeftPath.strokeColor = backPathColor;
                backLeftPath.segments[0].point = botLeftPath.segments[1].point;
                backLeftPath.segments[1].point = topLeftPath.segments[1].point;
            }
        }

        function resetVertexStrokeWidth() {
            topLeftCircle.strokeWidth=0;
            topRightCircle.strokeWidth=0;
            botLeftCircle.strokeWidth=0;
            botRightCircle.strokeWidth=0;
            topLeftCircle.strokeColor = topLeftCircle.fillColor = anchorFill;
            topRightCircle.strokeColor = topRightCircle.fillColor = anchorFill;
            botLeftCircle.strokeColor = botLeftCircle.fillColor = anchorFill;
            botRightCircle.strokeColor = botRightCircle.fillColor = anchorFill;
            
        }

        function dist(p1, p2) {
            var delta = p1 - p2;
            return (Math.sqrt(Math.pow(delta.x,2) + Math.pow(delta.y,2)));
        }

        function hideAllTestPaths() {
            topLeftPathTest.strokeColor='transparent';
            topRightPathTest.strokeColor='transparent';
            botLeftPathTest.strokeColor='transparent';
            botRightPathTest.strokeColor='transparent';
        }

        function testAll() {
            resetVertexStrokeWidth();
            selectedVertex = "none";

            //var score = testTopLeftPath() +  testTopRightPath() + testBotLeftPath() + testBotRightPath();

            //increaseScore(score);
            testPath(topLeftPath, scoreAnimationSpeedMS);

            setTimeout(function()  {
                testPath(topRightPath, scoreAnimationSpeedMS);
            }, scoreAnimationSpeedMS);
            setTimeout(function()  {
                testPath(botLeftPath, scoreAnimationSpeedMS);
            }, scoreAnimationSpeedMS*2);
            setTimeout(function()  {
                testPath(botRightPath, scoreAnimationSpeedMS);
            }, scoreAnimationSpeedMS*3);

            setTimeout(function()  {
                testPathLength(backTopPath, true, scoreAnimationSpeedMS);
            }, scoreAnimationSpeedMS*4);
            setTimeout(function()  {
                testPathLength(backRightPath, false, scoreAnimationSpeedMS);
            }, scoreAnimationSpeedMS*5);
            setTimeout(function()  {
                testPathLength(backBotPath, true, scoreAnimationSpeedMS);
            }, scoreAnimationSpeedMS*6);
            setTimeout(function()  {
                testPathLength(backLeftPath, false, scoreAnimationSpeedMS);
            }, scoreAnimationSpeedMS*7);

            setTimeout(function() {
                if (totalScore > bestScore) {
                    newRecordText.remove();
                    newRecordText = new PointText({point: new Point(frame.left + frame.right/2, frame.top + frame.bottom/2), content: "New Best Score!", fillColor : newBestScoreColor, justification: "center", fontSize: 0, fontFamily: 'Georgia, serif', fontWeight: '1000'})
                    newRecordText.tweenTo({fontSize: 50}, {'duration': scoreAnimationSpeedMS, 'easing': 'easeOutQuart'})
                }
            }, scoreAnimationSpeedMS*8); 
            setTimeout(function() {
                    if (totalScore > bestScore) {
                        newRecordText.tweenTo({fontSize: 0}, {'duration': scoreAnimationSpeedMS, 'easing': 'easeOutQuart'})
                    }
                }, scoreAnimationSpeedMS*9); 
            setTimeout(function() {
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                }
                initialize(10,1);
            }, scoreAnimationSpeedMS*10); 



/*
            setTimeout(() => {
                testPath(topRightPath);
                setTimeout(() => {
                    testPath(botLeftPath);
                    setTimeout(() => {
                        testPath(botRightPath);
                    }, 2000);
                }, 2000);
            }, 2000);
            */
            
            
            
        }

        function testPathLength(pathToTest, horizontal, speedms) {
            
            var p1 = pathToTest.segments[0].point;
            var p2 = pathToTest.segments[1].point;
            var p12avg = (p2+p1)/2;

            testPathAnimated.remove();
            testPathAnimated = new Path({strokeColor: testPathStrokeColor, strokeWidth: 2});
            testPathAnimated2.remove();
            testPathAnimated2 = new Path({strokeColor: testPathStrokeColor, strokeWidth: 2});
            var midBarPath = new Path({strokeColor: testPathStrokeColor, strokeWidth: 2});
            var p3 = new Point();
            var p4 = new Point();
            if (horizontal) {
                p3 = new Point(new Point(p1.x,p12avg.y));
                p4 = new Point(new Point(p2.x,p12avg.y));
            } else {
                p3 = new Point(new Point(p12avg.x,p1.y));
                p4 = new Point(new Point(p12avg.x,p2.y));
            }

            testPathAnimated.add(p3, p4);
            testPathAnimated2.add(p3, p4);
            midBarPath.add(p3 + (p4-p3)/2, p3 + (p4-p3)/2);

            var testScoreOffset = new Point(horizontal ? 0 : -(p1-p2).x/2-20, horizontal ? -(p1-p2).y/2-20 : 0);
            testScoreDecrementText.remove();
            testScoreDecrementText = new PointText({point: (p1 + p2)/2 + testScoreOffset, content: "", fillColor : testScoreDecrementColor, justification: "center", fontSize: 18, fontFamily: 'Georgia, serif', fontWeight: '1000'});
            testScoreDecrementText.content = "-30";


            var scoreDecrement = 25-Math.floor(Math.pow(horizontal ? (p1-p2).y : (p1-p2).x,2)/500*25);
            totalScore += scoreDecrement;
            testScoreDecrementText.tween(speedms/2).onUpdate = function(event) {
                var d = Math.pow(event.factor,1/8);
                testScoreDecrementText.content = Math.floor(scoreDecrement*d);
                testScoreDecrementText.fillColor = testScoreDecrementColor;

                testScoreDecrementText.point = midBarPath.segments[1].point + testScoreOffset;
                if (event.factor == 1) {
                    testScoreDecrementText.tweenTo({point: framePathTopText.point + new Point(0,40), 'fillColor.alpha': .5}, {'easing':'easeOutQuart', 'duration': speedms/8}).then(function() {testScoreDecrementText.tween(speedms/8).onUpdate = function(event) {
                        var d = Math.pow(event.factor,1/2);
                        testScoreDecrementText.content = (scoreDecrement < 0 ? "" : "+") + Math.floor(scoreDecrement*d);
                        framePathTopText.content = "Score: " + (totalScore - scoreDecrement + Math.floor(scoreDecrement*d));
                        testScoreDecrementText.fillColor.alpha = .5 - (.5*d);
                        
                        testPathAnimated.strokeColor.alpha = 1-d;
                        testPathAnimated2.strokeColor.alpha = 1-d;
                        midBarPath.strokeColor.alpha = 1-d;

                    }})
                }

            }

            
            testPathAnimated.tweenTo({
                'segments[0].point.x': p1.x, 
                'segments[0].point.y': p1.y,
                'segments[1].point.x': horizontal ? p2.x : p1.x, 
                'segments[1].point.y': horizontal ? p1.y : p2.y
            }, {'easing':'easeOutQuart', 'duration': speedms/4});

            testPathAnimated2.tweenTo({
                'segments[0].point.x': horizontal ? p1.x : p2.x, 
                'segments[0].point.y': horizontal ? p2.y : p1.y,
                'segments[1].point.x': p2.x, 
                'segments[1].point.y': p2.y
            }, {'easing':'easeOutQuart', 'duration': speedms/4});

            midBarPath.tweenTo({
                'segments[0].point.x': horizontal ? p1.x + (p2.x-p1.x)/2 : p1.x, 
                'segments[0].point.y': horizontal ? p1.y : p1.y + (p2.y-p1.y)/2,
                'segments[1].point.x': horizontal ? p1.x + (p2.x-p1.x)/2 : p2.x, 
                'segments[1].point.y': horizontal ? p2.y : p1.y + (p2.y-p1.y)/2
            }, {'easing':'easeOutQuart', 'duration': speedms/4});

            setTimeout(function() {
                midBarPath.remove();
            }, speedms);
            
            
        }
        

        function testPath(pathToTest, speedms) {
            var p1 = pathToTest.segments[0].point;
            var p2 = pathToTest.segments[1].point;
            var p2Length = (p2-p1).length;
            var p3 = new Point((p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x, vp.y);

            var center = p1;
            var vector = vp;
            
            var from = p1;
            var through = from.rotate(vector.angle / 2);
            var to = from.rotate(vector.angle);
            var end = center + to;

            testScoreDecrementText.remove();
            testScoreDecrementText = new PointText({point: new Point(frame.right/2, frame.top + 50), content: "", fillColor : testScoreDecrementColor, justification: "center", fontSize: 18, fontFamily: 'Georgia, serif', fontWeight: '1000'});
            testScoreDecrementText.content = "-30";

            var v1 = p1-p3;
            var v2 = p1-vp;

            var p4 = v1.rotate((v2.angle - v1.angle)/2);

            arc.remove();
            arc = new Path({strokeColor: testPathArcStrokeColor, strokeWidth: 2, dashArray: testPathArcDashArray});
            var start = -v1.normalize()*p2Length+p1;
            var end = -v2.normalize()*p2Length+p1;
            var curveSize = Math.abs(v1.angle - v2.angle)*p2Length/200;
            arc.add(start);
            arc.add(new Segment(start, new Point(0,0), new Point(0,0)));
            arc.add(start);

            testPathAnimated.remove();
            testPathAnimated = new Path({strokeColor: testPathStrokeColor, strokeWidth: 2});
            testPathAnimated.add(p1, p1);
            var scoreDecrement = 25-Math.floor(Math.abs(v2.angle - v1.angle));
            totalScore += scoreDecrement;
            testScoreDecrementText.tweenTo({fillColor: 'transparent'},speedms/4).then(function() {testScoreDecrementText.tween(speedms/2).onUpdate = function(event) {
                var d = Math.pow(event.factor,1/8);
                testScoreDecrementText.content = Math.floor(scoreDecrement*d);
                testScoreDecrementText.fillColor = testScoreDecrementColor;

                testScoreDecrementText.point = (p2 + p2.normalize()*20) * (1-d) + ((-p4.normalize()*p2Length+p1)+(-p4.normalize()*p2Length+p1).normalize()*20)*d+v1.normalize().rotate(90)*20;
                if (event.factor == 1) {
                    testScoreDecrementText.tweenTo({point: framePathTopText.point + new Point(0,40), 'fillColor.alpha': .5}, {'easing':'easeOutQuart', 'duration': speedms/8}).then(function() {testScoreDecrementText.tween(speedms/8).onUpdate = function(event) {
                        var d = Math.pow(event.factor,1/2);
                        testScoreDecrementText.content = (scoreDecrement < 0 ? "" : "+") + Math.floor(scoreDecrement*d);
                        framePathTopText.content = "Score: " + (totalScore - scoreDecrement + Math.floor(scoreDecrement*d));
                        testScoreDecrementText.fillColor.alpha = .5 - (.5*d);
                        arc.strokeColor.alpha = 1-d;
                        testPathAnimated.strokeColor.alpha = 1-d;

                    }})
                }

            }});
            /*
            .then(function() {
                //testScoreDecrementText.tweenTo({'point.x': testScoreTotalText.point.x, 'point.y': testScoreTotalText.point.y}, {'easing':'easeOutQuart', 'duration': 500})

                
            });
        */
            //p.tween({'segments[1].point': p3}, {'easing':'easeOutQuart', 'duration': 1000}).then(function() {p.tween({'segments[1].point': vp}, {'easing':'easeOutQuart', 'duration': 1000})})
            testPathAnimated.tweenTo({'segments[1].point.x': p3.x, 'segments[1].point.y': p3.y}, {'easing':'easeOutQuart', 'duration': speedms/4})
                .then(function() {
                    arc.tween({
                'segments[1].point.x': (-p4.normalize()*p2Length+p1).x,
                'segments[1].point.y': (-p4.normalize()*p2Length+p1).y,
                'segments[1].handleIn': (start-end).normalize(curveSize),
                'segments[1].handleOut': (end-start).normalize(curveSize),
                'segments[2].point.x': end.x,
                'segments[2].point.y': end.y,
            }, {'easing':'easeOutQuart', 'duration': speedms/2});
                    testPathAnimated.tweenTo({'segments[1].point.x': vp.x, 'segments[1].point.y': vp.y}, {'easing':'easeOutQuart', 'duration': 1000})
                });
            //    .then(function() {new Path(new Point())});

            
            
        }
/*
        function testTopLeftPath() {
            var p1 = topLeftPath.segments[0].point;
            var p2 = topLeftPath.segments[1].point;
            topLeftPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            topLeftPathTest.segments[1].point.y = vp.y;
            topLeftPathTest.strokeColor='red';

            return Math.pow(vp.x - topLeftPathTest.segments[1].point.x,2);
        }
        */
        function testTopRightPath() {
            var p1 = topRightPath.segments[0].point;
            var p2 = topRightPath.segments[1].point;
            topRightPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            topRightPathTest.segments[1].point.y = vp.y;
            topRightPathTest.strokeColor='red';
            return Math.pow(vp.x - topRightPathTest.segments[1].point.x,2);
        }
        function testBotLeftPath() {
            var p1 = botLeftPath.segments[0].point;
            var p2 = botLeftPath.segments[1].point;
            botLeftPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            botLeftPathTest.segments[1].point.y = vp.y;
            botLeftPathTest.strokeColor='red';
            return Math.pow(vp.x - botLeftPathTest.segments[1].point.x,2);
        }
        function testBotRightPath() {
            var p1 = botRightPath.segments[0].point;
            var p2 = botRightPath.segments[1].point;
            botRightPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            botRightPathTest.segments[1].point.y = vp.y;
            botRightPathTest.strokeColor='red';
            return Math.pow(vp.x - botRightPathTest.segments[1].point.x,2);
        }
        function randInt(min, max) {
            return Math.floor(Math.random() * (max - min) ) + min;
        }

        function increaseScore(amt) {
            currentScore += amt;
            framePathTopText.content = "Score: " + Math.floor(currentScore);
        }
    </script>
</head>

<body>
    <canvas id="canvas" resize></canvas>
</body>

</html>