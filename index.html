<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Perspective Trainer</title>
    <link rel="stylesheet" href="css/style.css">

    <script type="text/javascript" src="js/paper-full.min.js"></script>
    <script type="text/paperscript" canvas="canvas">

        /*
        TODO
        touch support
        back rectangle scoring
        variable difficulty via longer guide lines
        */

        var guidePercent = .5;
        var pointDistPercent = .5;
        var rectSizeProp = .4;
        var rectSizePropVar = .35;


        var path;
        var clickStartPoint = new Point(0,0);

        var frame = new Rectangle();
        frame.left = 30;
        frame.right = window.innerWidth-30;
        frame.top = 60;
        frame.bottom = window.innerHeight-30;

        var framePath = new Path.Rectangle(frame);
        framePath.strokeColor='black';

        var rect = new Rectangle();
        rect.left = randInt(frame.left+20, frame.right-(frame.right-frame.left)*(rectSizeProp+rectSizePropVar)-30);
        rect.right = rect.left + randInt((frame.right-frame.left)*(rectSizeProp-rectSizePropVar), (frame.right-frame.left)*(rectSizeProp+rectSizePropVar));
        rect.top = randInt(frame.top+20, frame.bottom-(frame.bottom-frame.top)*(rectSizeProp+rectSizePropVar)-30);
        rect.bottom = rect.top + randInt((frame.bottom-frame.top)*(rectSizeProp-rectSizePropVar), (frame.bottom-frame.top)*(rectSizeProp+rectSizePropVar));

        var rectPath = new Path.Rectangle(rect);
        rectPath.strokeColor='black';

        var vp = new Point(randInt(frame.left + 20,frame.right-20),randInt(frame.top+20, frame.bottom-20));
        var horizonPath = new Path();
        horizonPath.strokeColor='black';
        horizonPath.add(new Point(frame.left, vp.y), new Point(frame.right, vp.y));

        var vpCircle = new Path.Circle(vp, 3);
        vpCircle.fillColor='black';

        var topLeftCircle = new Path.Circle(new Point(0, 0), 3);
        topLeftCircle.position = new Point(rect.left, rect.top);
        topLeftCircle.fillColor='black';
        topLeftCircle.strokeColor='black';
        topLeftCircle.strokeWidth=0;

        var topRightCircle = new Path.Circle(new Point(0, 0), 3);
        topRightCircle.position = new Point(rect.right, rect.top);
        topRightCircle.fillColor='black';
        topRightCircle.strokeColor='black';
        topRightCircle.strokeWidth=0;

        var botLeftCircle = new Path.Circle(new Point(0, 0), 3);
        botLeftCircle.position = new Point(rect.left, rect.bottom);
        botLeftCircle.fillColor='black';
        botLeftCircle.strokeColor='black';
        botLeftCircle.strokeWidth=0;

        var botRightCircle = new Path.Circle(new Point(0, 0), 3);
        botRightCircle.position = new Point(rect.right, rect.bottom);
        botRightCircle.fillColor='black';
        botRightCircle.strokeColor='black';
        botRightCircle.strokeWidth=0;

        var selectedVertex = "none";
        var activePath = "none";

        var topLeftPath = new Path();
        topLeftPath.add(new Point(rect.left, rect.top), new Point(rect.left, rect.top));
        topLeftPath.strokeColor = 'black';
        var topRightPath = new Path();
        topRightPath.add(new Point(rect.right, rect.top), new Point(rect.right, rect.top));
        topRightPath.strokeColor = 'transparent';
        var botLeftPath = new Path();
        botLeftPath.add(new Point(rect.left, rect.bottom), new Point(rect.left, rect.bottom));
        botLeftPath.strokeColor = 'transparent';
        var botRightPath = new Path();
        botRightPath.add(new Point(rect.right, rect.bottom), new Point(rect.right, rect.bottom));
        botRightPath.strokeColor = 'transparent';

        var topLeftPathTest = new Path();
        topLeftPathTest.strokeColor = 'transparent';
        topLeftPathTest.add(new Point(rect.left, rect.top));
        topLeftPathTest.add(vp);
        
        var topRightPathTest = new Path();
        topRightPathTest.strokeColor = 'transparent';
        topRightPathTest.add(new Point(rect.right, rect.top));
        topRightPathTest.add(vp);

        var botLeftPathTest = new Path();
        botLeftPathTest.strokeColor = 'transparent';
        botLeftPathTest.add(new Point(rect.left, rect.bottom));
        botLeftPathTest.add(vp);

        var botRightPathTest = new Path();
        botRightPathTest.strokeColor = 'transparent';
        botRightPathTest.add(new Point(rect.right, rect.bottom));
        botRightPathTest.add(vp);

        var topLeftPathGuide = new Path();
        topLeftPathGuide.strokeColor = 'transparent';
        topLeftPathGuide.add(new Point(rect.left, rect.top));
        topLeftPathGuide.add(vp);
        
        var topRightPathGuide = new Path();
        topRightPathGuide.strokeColor = 'transparent';
        topRightPathGuide.add(new Point(rect.right, rect.top));
        topRightPathGuide.add(vp);

        var botLeftPathGuide = new Path();
        botLeftPathGuide.strokeColor = 'transparent';
        botLeftPathGuide.add(new Point(rect.left, rect.bottom));
        botLeftPathGuide.add(vp);

        var botRightPathGuide = new Path();
        botRightPathGuide.strokeColor = 'transparent';
        botRightPathGuide.add(new Point(rect.right, rect.bottom));
        botRightPathGuide.add(vp);

        var backPathColor = 'grey';
        var backTopPath = new Path();
        backTopPath.strokeColor = 'trasparent';
        backTopPath.add(new Point(0,0), new Point(0,0));
        var backLeftPath = new Path();
        backLeftPath.strokeColor = 'trasparent';
        backLeftPath.add(new Point(0,0), new Point(0,0));
        var backRightPath = new Path();
        backRightPath.strokeColor = 'trasparent';
        backRightPath.add(new Point(0,0), new Point(0,0));
        var backBotPath = new Path();
        backBotPath.strokeColor = 'trasparent';
        backBotPath.add(new Point(0,0), new Point(0,0));

        var backGuideColor = '#CCEE55CC';
        var backGuideArray = [3, 5];
        var topLeftBackHorizontalGuide = new Path();
        topLeftBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
        topLeftBackHorizontalGuide.strokeColor = backGuideColor;
        topLeftBackHorizontalGuide.dashArray = backGuideArray;
        var topLeftBackVerticalGuide = new Path();
        topLeftBackVerticalGuide.add(new Point(0,0), new Point(0,0));
        topLeftBackVerticalGuide.strokeColor = backGuideColor;
        topLeftBackVerticalGuide.dashArray = backGuideArray;
        var topRightBackHorizontalGuide = new Path();
        topRightBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
        topRightBackHorizontalGuide.strokeColor = backGuideColor;
        topRightBackHorizontalGuide.dashArray = backGuideArray;
        var topRightBackVerticalGuide = new Path();
        topRightBackVerticalGuide.add(new Point(0,0), new Point(0,0));
        topRightBackVerticalGuide.strokeColor = backGuideColor;
        topRightBackVerticalGuide.dashArray = backGuideArray;
        var botLeftBackHorizontalGuide = new Path();
        botLeftBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
        botLeftBackHorizontalGuide.strokeColor = backGuideColor;
        botLeftBackHorizontalGuide.dashArray = backGuideArray;
        var botLeftBackVerticalGuide = new Path();
        botLeftBackVerticalGuide.add(new Point(0,0), new Point(0,0));
        botLeftBackVerticalGuide.strokeColor = backGuideColor;
        botLeftBackVerticalGuide.dashArray = backGuideArray;
        var botRightBackHorizontalGuide = new Path();
        botRightBackHorizontalGuide.add(new Point(0,0), new Point(0,0));
        botRightBackHorizontalGuide.strokeColor = backGuideColor;
        botRightBackHorizontalGuide.dashArray = backGuideArray;
        var botRightBackVerticalGuide = new Path();
        botRightBackVerticalGuide.add(new Point(0,0), new Point(0,0));
        botRightBackVerticalGuide.strokeColor = backGuideColor;
        botRightBackVerticalGuide.dashArray = backGuideArray;
        

        var buttonTest = new Path.Rectangle(new Rectangle(10,10,100,35),6);
        buttonTest.fillColor='#00000011';
        var buttonTestText = new PointText(buttonTest.position);
        buttonTestText.content = 'Test';
        buttonTestText.justification = 'center';
        buttonTestText.fillColor = 'black';
        buttonTestText.onMouseDown = buttonTest.onMouseDown = function(event) { testAll(); buttonTest.fillColor = '#00000033';}
        buttonTestText.onMouseUp = buttonTest.onMouseUp = function(event) { hideAllTestPaths(); buttonTest.fillColor = '#00000011';}
        
        var scorePanel = new Path.Rectangle(new Rectangle(120,10,200,35),6);
        scorePanel.fillColor='#00000011';
        var scoreLabelText = new PointText(scorePanel.position + new Point(-80, 0));
        scoreLabelText.content = 'Score:';
        scoreLabelText.justification = 'left';
        scoreLabelText.fillColor = 'black';
        var scoreValueText = new PointText(scorePanel.position + new Point(-40, 0));
        scoreValueText.content = '0';
        scoreValueText.justification = 'left';
        scoreValueText.fillColor = 'black';

        var buttonDifficulty = new Path.Rectangle(new Rectangle(330,10,100,35),6);
        buttonDifficulty.fillColor='#00000011';
        var buttonDifficultyText = new PointText(buttonDifficulty.position);
        buttonDifficultyText.content = 'Easy';
        buttonDifficultyText.justification = 'center';
        buttonDifficultyText.fillColor = 'black';
        buttonDifficultyText.onMouseDown = buttonDifficulty.onMouseDown = function(event) { buttonDifficulty.fillColor = '#00000033';}
        buttonDifficultyText.onMouseUp = buttonDifficulty.onMouseUp = function(event) { 
            if (buttonDifficultyText.content == 'Easy') {
                buttonDifficultyText.content = 'Moderate';
                guidePercent = .3;
                backGuideColor = '#CCEE5599';
            } else if (buttonDifficultyText.content == 'Moderate') {
                buttonDifficultyText.content = 'Hard';
                guidePercent = .1;
                backGuideColor = '#CCEE5555';
            } else if (buttonDifficultyText.content == 'Hard') {
                buttonDifficultyText.content = 'No Help!';
                guidePercent = 0;
                backGuideColor = '#CCEE5500';
            } else if (buttonDifficultyText.content == 'No Help!') {
                buttonDifficultyText.content = 'Easy';
                guidePercent = .5;
                backGuideColor = '#CCEE55CC';
            } 
            buttonDifficulty.fillColor = '#00000011';
        }


        var randDistScale = 1;

        function onMouseDrag(event) {
            var cursorpoint = event.point;
            if (event.point.x < frame.left) return;
            if (event.point.x > frame.right) return;
            if (event.point.y < frame.top) return;
            if (event.point.y > frame.bottom) return;

            if (activePath == "none") return;

            if (activePath == "topLeft") {
                cursorpoint = topLeftPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, topLeftPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(topLeftPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = topLeftPath.segments[0].point.x + (cursorpoint.x - topLeftPath.segments[0].point.x)/scalingFactor;
                var y = topLeftPath.segments[0].point.y + (cursorpoint.y - topLeftPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    topLeftCircle.strokeColor = 'red';
                    topLeftPath.strokeColor = 'red';
                } else {
                    topLeftCircle.strokeColor = 'black';
                    topLeftPath.strokeColor = 'black';

                    topLeftPath.segments[1].point.x = x;
                    topLeftPath.segments[1].point.y = y;
    
                    topLeftCircle.position = new Point(x, y);
                }
            } else if (activePath == "topRight") {
                cursorpoint = topRightPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, topRightPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(topRightPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = topRightPath.segments[0].point.x + (cursorpoint.x - topRightPath.segments[0].point.x)/scalingFactor;
                var y = topRightPath.segments[0].point.y + (cursorpoint.y - topRightPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    topRightCircle.strokeColor = 'red';
                    topRightPath.strokeColor = 'red';
                } else {
                    topRightCircle.strokeColor = 'black';
                    topRightPath.strokeColor = 'black';

                    topRightPath.segments[1].point.x = x;
                    topRightPath.segments[1].point.y = y;
    
                    topRightCircle.position = new Point(x, y);
                }
            } else if (activePath == "botLeft") {
                cursorpoint = botLeftPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, botLeftPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(botLeftPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = botLeftPath.segments[0].point.x + (cursorpoint.x - botLeftPath.segments[0].point.x)/scalingFactor;
                var y = botLeftPath.segments[0].point.y + (cursorpoint.y - botLeftPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    botLeftCircle.strokeColor = 'red';
                    botLeftPath.strokeColor = 'red';
                } else {
                    botLeftCircle.strokeColor = 'black';
                    botLeftPath.strokeColor = 'black';

                    botLeftPath.segments[1].point.x = x;
                    botLeftPath.segments[1].point.y = y;
    
                    botLeftCircle.position = new Point(x, y);
                }
            } else if (activePath == "botRight") {
                cursorpoint = botRightPath.segments[0].point - clickStartPoint + cursorpoint;

                var d = dist(cursorpoint, botRightPath.segments[0].point);
                var scalingFactor = Math.max(1, d/(dist(botRightPath.segments[0].point, vp)*pointDistPercent*randDistScale));
                var x = botRightPath.segments[0].point.x + (cursorpoint.x - botRightPath.segments[0].point.x)/scalingFactor;
                var y = botRightPath.segments[0].point.y + (cursorpoint.y - botRightPath.segments[0].point.y)/scalingFactor;
                
                if (scalingFactor > 1) {
                    botRightCircle.strokeColor = 'red';
                    botRightPath.strokeColor = 'red';
                } else {
                    botRightCircle.strokeColor = 'black';
                    botRightPath.strokeColor = 'black';

                    botRightPath.segments[1].point.x = x;
                    botRightPath.segments[1].point.y = y;
    
                    botRightCircle.position = new Point(x, y);
                }
            }
            showGuides();
        }
        
        function onMouseDown(event) {

            if (event.point.x < frame.left) return;
            if (event.point.x > frame.right) return;
            if (event.point.y < frame.top) return;
            if (event.point.y > frame.bottom) return;

            selectVertex(event);
            randDistScale = randInt(100,140)/100;
            if (selectedVertex == "none") {
                return;
            }
            hideAllTestPaths();
            clickStartPoint = event.point;
            
            
            if (selectedVertex == "topLeft") {  
                topLeftPath.segments[0].point = new Point(rect.left, rect.top);
                activePath = "topLeft";
                topLeftPath.strokeColor='green';
                
                backLeftPath.strokeColor = 'transparent';
                backTopPath.strokeColor = 'transparent';

            } else if (selectedVertex == "topRight") {  
                topRightPath.add(new Point(rect.right, rect.top));
                activePath = "topRight";
                topRightPath.strokeColor='transparent';
                
                backRightPath.strokeColor = 'transparent';
                backTopPath.strokeColor = 'transparent';
            } else if (selectedVertex == "botLeft") {  
                botLeftPath.add(new Point(rect.left, rect.bottom));
                activePath = "botLeft";
                botLeftPath.strokeColor='transparent';

                backLeftPath.strokeColor = 'transparent';
                backBotPath.strokeColor = 'transparent';
            } else if (selectedVertex == "botRight") {  
                botRightPath.add(new Point(rect.right, rect.bottom));
                activePath = "botRight";
                botRightPath.strokeColor='transparent';

                backRightPath.strokeColor = 'transparent';
                backBotPath.strokeColor = 'transparent';
            }
        }

        function selectVertex(event) {
            var grabDist = 50;
            var circleGrowWidth = 5;

            if (dist(event.point, topLeftCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                topLeftCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "topLeft";

            } else if (dist(event.point, topRightCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                topRightCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "topRight";

            } else if (dist(event.point, botLeftCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                botLeftCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "botLeft";

            } else if (dist(event.point, botRightCircle.position) < grabDist) {
                resetVertexStrokeWidth();
                botRightCircle.strokeWidth=circleGrowWidth;
                selectedVertex = "botRight";

            } else if (event.point.x < frame.left | event.point.x > frame.right | event.point.y < frame.top | event.point.y > frame.bottom) {
                selectedVertex = "none";
                resetVertexStrokeWidth();
            }
        }


        function onMouseUp(event) {
            if (activePath == "topLeft") {
                topLeftPath.strokeColor = 'black';
            } else if (activePath == "topRight") {
                topRightPath.strokeColor = 'black';
            } else if (activePath == "botLeft"){
                botLeftPath.strokeColor = 'black';
            } else if (activePath == "botRight") {
                botRightPath.strokeColor = 'black';
            }
            
            //activePath = "none";
            //selectedVertex = "none";
            topLeftCircle.position = new Point(rect.left, rect.top);
            topRightCircle.position = new Point(rect.right, rect.top);
            botLeftCircle.position = new Point(rect.left, rect.bottom);
            botRightCircle.position = new Point(rect.right, rect.bottom);
            drawBackLines();
            hideGuides();
        }
        function clamp(min, max, v) {
            return Math.min(max, Math.max(min, v));
        }

        function showGuides(event) {
            if (activePath == "topLeft") {
                topLeftPathGuide.strokeColor = "blue";
                topLeftPathGuide.dashArray = [2,4];

                topLeftPathGuide.segments[0].point.x = topLeftPath.segments[1].point.x;
                topLeftPathGuide.segments[0].point.y = topLeftPath.segments[1].point.y;

                var p1 = topLeftPath.segments[0].point;
                var p2 = topLeftPath.segments[1].point;

                var targety = topLeftPathGuide.segments[0].point.y + (vp.y - topLeftPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                topLeftPathGuide.segments[1].point.x = xclamped;
                topLeftPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;

            } else if (activePath == "topRight") {
                topRightPathGuide.strokeColor = "blue";
                topRightPathGuide.dashArray = [2,4];

                topRightPathGuide.segments[0].point.x = topRightPath.segments[1].point.x;
                topRightPathGuide.segments[0].point.y = topRightPath.segments[1].point.y;

                var p1 = topRightPath.segments[0].point;
                var p2 = topRightPath.segments[1].point;

                var targety = topRightPathGuide.segments[0].point.y + (vp.y - topRightPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                topRightPathGuide.segments[1].point.x = xclamped;
                topRightPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;

            } else if (activePath == "botLeft") {
                botLeftPathGuide.strokeColor = "blue";
                botLeftPathGuide.dashArray = [2,4];

                botLeftPathGuide.segments[0].point.x = botLeftPath.segments[1].point.x;
                botLeftPathGuide.segments[0].point.y = botLeftPath.segments[1].point.y;

                var p1 = botLeftPath.segments[0].point;
                var p2 = botLeftPath.segments[1].point;

                var targety = botLeftPathGuide.segments[0].point.y + (vp.y - botLeftPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                botLeftPathGuide.segments[1].point.x = xclamped;
                botLeftPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;

            } else if (activePath == "botRight") {
                botRightPathGuide.strokeColor = "blue";
                botRightPathGuide.dashArray = [2,4];

                botRightPathGuide.segments[0].point.x = botRightPath.segments[1].point.x;
                botRightPathGuide.segments[0].point.y = botRightPath.segments[1].point.y;

                var p1 = botRightPath.segments[0].point;
                var p2 = botRightPath.segments[1].point;

                var targety = botRightPathGuide.segments[0].point.y + (vp.y - botRightPathGuide.segments[0].point.y) * guidePercent;

                var x = (p1.x-p2.x)*((targety-p1.y)/(p1.y-p2.y)) + p1.x;
                var xclamped = clamp(frame.left, frame.right, x);
                var scale = (x-p2.x)/(xclamped-p2.x);

                botRightPathGuide.segments[1].point.x = xclamped;
                botRightPathGuide.segments[1].point.y = (targety-p2.y)/scale+p2.y;
            }

            if (topLeftPath.segments[1].point != topLeftPath.segments[0].point) {
                topLeftBackHorizontalGuide.strokeColor = backGuideColor;
                topLeftBackHorizontalGuide.segments[0].point = new Point(frame.left, topLeftPath.segments[1].point.y);
                topLeftBackHorizontalGuide.segments[1].point = new Point(frame.right, topLeftPath.segments[1].point.y);
                topLeftBackVerticalGuide.strokeColor = backGuideColor;
                topLeftBackVerticalGuide.segments[0].point = new Point(topLeftPath.segments[1].point.x, frame.top);
                topLeftBackVerticalGuide.segments[1].point = new Point(topLeftPath.segments[1].point.x, frame.bottom);
            }
            if (topRightPath.segments[1].point != topRightPath.segments[0].point) {
                topRightBackHorizontalGuide.strokeColor = backGuideColor;
                topRightBackHorizontalGuide.segments[0].point = new Point(frame.left, topRightPath.segments[1].point.y);
                topRightBackHorizontalGuide.segments[1].point = new Point(frame.right, topRightPath.segments[1].point.y);
                topRightBackVerticalGuide.strokeColor = backGuideColor;
                topRightBackVerticalGuide.segments[0].point = new Point(topRightPath.segments[1].point.x, frame.top);
                topRightBackVerticalGuide.segments[1].point = new Point(topRightPath.segments[1].point.x, frame.bottom);
            }
            if (botLeftPath.segments[1].point != botLeftPath.segments[0].point) {
                botLeftBackHorizontalGuide.strokeColor = backGuideColor;
                botLeftBackHorizontalGuide.segments[0].point = new Point(frame.left, botLeftPath.segments[1].point.y);
                botLeftBackHorizontalGuide.segments[1].point = new Point(frame.right, botLeftPath.segments[1].point.y);
                botLeftBackVerticalGuide.strokeColor = backGuideColor;
                botLeftBackVerticalGuide.segments[0].point = new Point(botLeftPath.segments[1].point.x, frame.top);
                botLeftBackVerticalGuide.segments[1].point = new Point(botLeftPath.segments[1].point.x, frame.bottom);
            }
            if (botRightPath.segments[1].point != botRightPath.segments[0].point) {
                botRightBackHorizontalGuide.strokeColor = backGuideColor;
                botRightBackHorizontalGuide.segments[0].point = new Point(frame.left, botRightPath.segments[1].point.y);
                botRightBackHorizontalGuide.segments[1].point = new Point(frame.right, botRightPath.segments[1].point.y);
                botRightBackVerticalGuide.strokeColor = backGuideColor;
                botRightBackVerticalGuide.segments[0].point = new Point(botRightPath.segments[1].point.x, frame.top);
                botRightBackVerticalGuide.segments[1].point = new Point(botRightPath.segments[1].point.x, frame.bottom);
            }
            
            
        }
        function hideGuides() {
            topLeftPathGuide.strokeColor = "transparent";
            topRightPathGuide.strokeColor = "transparent";
            botLeftPathGuide.strokeColor = "transparent";
            botRightPathGuide.strokeColor = "transparent";
            topLeftBackHorizontalGuide.strokeColor = 'transparent';
            topLeftBackVerticalGuide.strokeColor = 'transparent';
            topRightBackHorizontalGuide.strokeColor = 'transparent';
            topRightBackVerticalGuide.strokeColor = 'transparent';
            botLeftBackHorizontalGuide.strokeColor = 'transparent';
            botLeftBackVerticalGuide.strokeColor = 'transparent';
            botRightBackHorizontalGuide.strokeColor = 'transparent';
            botRightBackVerticalGuide.strokeColor = 'transparent';
        }

        function drawBackLines() {

            if (topLeftPath.segments[1].point != topLeftPath.segments[0].point & topRightPath.segments[1].point != topRightPath.segments[0].point) {
                backTopPath.strokeColor = backPathColor;
                backTopPath.segments[0].point = topLeftPath.segments[1].point;
                backTopPath.segments[1].point = topRightPath.segments[1].point;
            }
            if (topRightPath.segments[1].point != topRightPath.segments[0].point & botRightPath.segments[1].point != botRightPath.segments[0].point) {
                backRightPath.strokeColor = backPathColor;
                backRightPath.segments[0].point = topRightPath.segments[1].point;
                backRightPath.segments[1].point = botRightPath.segments[1].point;
            }
            if (botRightPath.segments[1].point != botRightPath.segments[0].point & botLeftPath.segments[1].point != botLeftPath.segments[0].point) {
                backBotPath.strokeColor = backPathColor;
                backBotPath.segments[0].point = botRightPath.segments[1].point;
                backBotPath.segments[1].point = botLeftPath.segments[1].point;
            }
            if (topLeftPath.segments[1].point != topLeftPath.segments[0].point & botLeftPath.segments[1].point != botLeftPath.segments[0].point) {
                backLeftPath.strokeColor = backPathColor;
                backLeftPath.segments[0].point = botLeftPath.segments[1].point;
                backLeftPath.segments[1].point = topLeftPath.segments[1].point;
            }
        }

        function resetVertexStrokeWidth() {
            topLeftCircle.strokeWidth=0;
            topRightCircle.strokeWidth=0;
            botLeftCircle.strokeWidth=0;
            botRightCircle.strokeWidth=0;
        }

        function dist(p1, p2) {
            var delta = p1 - p2;
            return (Math.sqrt(Math.pow(delta.x,2) + Math.pow(delta.y,2)));
        }

        function hideAllTestPaths() {
            topLeftPathTest.strokeColor='transparent';
            topRightPathTest.strokeColor='transparent';
            botLeftPathTest.strokeColor='transparent';
            botRightPathTest.strokeColor='transparent';
        }

        function testAll() {
            var score = testTopLeftPath() +  testTopRightPath() + testBotLeftPath() + testBotRightPath();
            scoreValueText.content = score;
        }

        function testTopLeftPath() {
            var p1 = topLeftPath.segments[0].point;
            var p2 = topLeftPath.segments[1].point;
            topLeftPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            topLeftPathTest.segments[1].point.y = vp.y;
            topLeftPathTest.strokeColor='red';
            return Math.pow(vp.x - topLeftPathTest.segments[1].point.x,2);
        }
        function testTopRightPath() {
            var p1 = topRightPath.segments[0].point;
            var p2 = topRightPath.segments[1].point;
            topRightPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            topRightPathTest.segments[1].point.y = vp.y;
            topRightPathTest.strokeColor='red';
            return Math.pow(vp.x - topRightPathTest.segments[1].point.x,2);
        }
        function testBotLeftPath() {
            var p1 = botLeftPath.segments[0].point;
            var p2 = botLeftPath.segments[1].point;
            botLeftPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            botLeftPathTest.segments[1].point.y = vp.y;
            botLeftPathTest.strokeColor='red';
            return Math.pow(vp.x - botLeftPathTest.segments[1].point.x,2);
        }
        function testBotRightPath() {
            var p1 = botRightPath.segments[0].point;
            var p2 = botRightPath.segments[1].point;
            botRightPathTest.segments[1].point.x = (p1.x-p2.x)*((vp.y-p1.y)/(p1.y-p2.y)) + p1.x;
            botRightPathTest.segments[1].point.y = vp.y;
            botRightPathTest.strokeColor='red';
            return Math.pow(vp.x - botRightPathTest.segments[1].point.x,2);
        }
        function randInt(min, max) {
            return Math.floor(Math.random() * (max - min) ) + min;
        }
    </script>
</head>
<body>
    <canvas id="canvas" resize></canvas>
</body>
</html>
